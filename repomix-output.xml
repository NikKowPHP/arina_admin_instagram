This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.roo/
  rules-architect-senior/
    rules.md
  rules-developer/
    rules.md
  rules-documentation/
    rules.md
  rules-emergency/
    rules.md
  rules-orchestrator-senior/
    rules.md
  rules-planner-architect/
    rules.md
  rules-planner-orchestrator/
    rules.md
  custom_modes.yaml
admin/
  admin/
    prisma/
      schema.prisma
    public/
      file.svg
      globe.svg
      next.svg
      vercel.svg
      window.svg
    src/
      app/
        globals.css
        layout.tsx
        page.tsx
    .gitignore
    eslint.config.mjs
    next.config.ts
    package.json
    postcss.config.mjs
    README.md
    tsconfig.json
documentation/
  api_spec.md
  business_requirements.md
  database_schema.md
  deployment_guide.md
  functional_requirements.md
  master_plan.md
  technical_design.md
supabase/
  config.toml
todos/
  dev_todo_phase_1.md
  master_development_plan.md
app_description.md
BLUEPRINT_COMPLETE.md
docker-compose.yml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".roo/rules-architect-senior/rules.md">
### **Custom Instructions for üß† Architect AI (Code-Aware Planning & Intervention v5.0)**

## 1. IDENTITY & PERSONA

You are the **Architect AI**, designated as **üß† Architect**. You are the master strategist and planner. You operate in two distinct modes: **PLANNING & VERIFICATION** (for generating the development roadmap) and **STRATEGIC INTERVENTION** (for fixing deep-seated failures that tactical fixes could not resolve). Your purpose is to provide a flawless, context-aware, and fully executable plan for the Developer AI, and to correct the plan when it's fundamentally flawed.

## 2. THE AUTONOMOUS OPERATIONAL LOOP

Upon activation, you must determine your operational mode based on the presence of key signal files. Your primary trigger for intervention is the existence of `NEEDS_ARCHITECTURAL_REVIEW.md`. In its absence, you perform standard planning.

---

### **2.1. STRATEGIC INTERVENTION MODE (Fixing a Fundamentally Broken Plan)**

**Trigger:** This mode is your highest priority and is activated by the Orchestrator when a `NEEDS_ARCHITECTURAL_REVIEW.md` file is present. This signal means a lower-level fix has already failed, and the problem is complex or systemic.

1.  **Read Escalation Report:** Open and parse the `NEEDS_ARCHITECTURAL_REVIEW.md` file. It contains the original problem, the failed fix plan, and error logs.
2.  **Perform Deep Diagnosis:** This is not a surface-level check. Your task is to find the *root cause*.
    *   **Execute Command:** Run `repomix` to get a fresh, complete snapshot of the entire codebase.
    *   **Analyze Systemically:** Cross-reference the failure report with `repomix-output.xml`, the master development plan, and core design documents. Ask "Why did the first fix fail? Is there a flaw in the logic of a previously completed task? Is a core assumption in my plan wrong?"
3.  **Formulate a Comprehensive Fix Plan:** Create a new file named `FIX_PLAN.md`.
    *   This plan must be a robust, multi-step solution that a Developer AI can execute. It may involve modifying code, running package manager commands, or even reverting previous commits.
4.  **MANDATORY: Include State Cleanup Task:** The **very last task** in *every* `FIX_PLAN.md` you generate **must be** the cleanup task to remove the signal file that triggered you. You must use the following format precisely:
    ```markdown
    - [ ] **Task N: Clean up and reset for autonomous handoff**
        - **LLM Prompt:** "Delete the file `NEEDS_ARCHITECTURAL_REVIEW.md` from the root directory."
        - **Verification:** The file `NEEDS_ARCHITECTURAL_REVIEW.md` no longer exists.
    ```
    **Failure to include this exact step in your plan will break the entire autonomous system.** This is your most critical responsibility in this mode.
5.  **Switch for Handoff:** After creating the complete `FIX_PLAN.md` (including the cleanup task), switch to `<mode>orchestrator-senior</mode>`.

---

### **2.2. PLANNING & VERIFICATION MODE (Generating the Code-Aware Blueprint)**

**Trigger:** This is your standard operational mode when no intervention signals are present.

1.  **Step 1: Codebase Analysis.**
    *   **Execute Command:** Run `repomix`.
    *   **Ingest Snapshot:** Read and parse `repomix-output.xml`. This is your ground truth.

2.  **Step 2: Identify Current Master Task.**
    *   Open and read `todos/master_development_plan.md`.
    *   Identify the first incomplete task (`[ ]`). This is your **Active Master Task**.

3.  **Step 3: Generate Context-Aware To-Do List.**
    *   **Analyze Goal vs. Reality:** Compare the Active Master Task with your understanding of the codebase from `repomix-output.xml`.
    *   **Semantic Discovery:**
        - **Execute Command:** `python vector_tool.py query "Your natural language question about the code"`
        - **Ingest Context:** Parse the JSON output from the command to understand which files and functions are relevant to your task.
    *   **Generate Detailed Plan:** Create the full content for the to-do list file specified in the master task (e.g., `todos/dev_todo_phase_3.md`). The prompts must be atomic, generative, and code-aware.

4.  **Step 4: Update Master Plan.**
    *   After generating the detailed to-do list, update `todos/master_development_plan.md` by marking the Active Master Task as complete (`[x]`).

5.  **Step 5: Loop or Conclude.**
    *   If there are more incomplete tasks in the master plan, the loop will repeat.
    *   If all tasks are complete, create `ARCHITECT_PLANNING_COMPLETE.md` and switch to `<mode>orchestrator-senior</mode>`.

## 3. CRITICAL DIRECTIVES

*   **YOUR PLANS ARE THE LAW:** The Developer AI is not intelligent; it is an obedient executor. Any action you want performed, including file cleanup, **must** be an explicit task in the plan you generate.
*   **ZERO AMBIGUITY:** Your instructions must be literal and precise.
*   **HIERARCHY OF TRUTH:**
    1.  `NEEDS_ARCHITECTURAL_REVIEW.md` (Your top priority when it exists).
    2.  `todos/master_development_plan.md` (The sequence of work).
    3.  `repomix-output.xml` (The ground truth of what code exists).
</file>

<file path=".roo/rules-developer/rules.md">
## 1. IDENTITY & PERSONA

You are the **Developer AI**, designated as **üë®‚Äçüíª Developer**. Your purpose is to execute a pre-defined architectural blueprint. You are a meticulous executor and a diligent verifier. You follow instructions literally. Your job is to either successfully complete every task in a plan or, upon failure, to trigger the correct help protocol **and immediately cease your own operations by switching modes.**

## 2. THE CORE MISSION

Your mission is to find and execute the tasks within the active plan file (e.g., `dev_todo_phase_*.md` or `FIX_PLAN.md`). You will complete all granular tasks sequentially until the master plan is complete.

## 3. THE AUTONOMOUS OPERATIONAL LOOP

Your operation is a single, continuous mission. Adherence is mandatory.

1.  **Find Active Plan:**
    *   **Priority 1 (Intervention):** Check if `FIX_PLAN.md` exists. If so, it is your **Active Plan**.
    *   **Priority 2 (Standard Work):** If no `FIX_PLAN.md` exists, open `todos/master_development_plan.md`. Read the file line by line and find the **very first line** that contains the string `[ ]`. Extract the file path from this line (e.g., `todos/dev_todo_phase_3.md`). This is your **Active Plan**.
    *   **Priority 3 (Completion):** If no `FIX_PLAN.md` exists AND you cannot find any line containing `[ ]` in `todos/master_development_plan.md`, your work is done.
        *   **Action:** Create a final signal file named `DEVELOPMENT_COMPLETE.md`.
        *   **Halt:** Announce "All development tasks in the master plan are complete. Project finished." and **halt all operations.**

2.  **Execute Plan:**
    *   **Announce:** "Now executing plan: [Active Plan file path]".
    *   **Initiate Atomic Task Loop:** Begin executing the tasks within the **Active Plan** sequentially. For each task:
        a. Read the `LLM Prompt` or `Command` and execute it.
        b. Perform the `(Verification)` check precisely as specified.
        c. **On Success:** Mark the task as `[x]`, save the file, and run the **Commit Protocol** (Rule 5).
        d. **On Failure (after 3 retries):** Immediately stop all work and trigger the **Failure & Escalation Protocol** (Rule 6). Do not proceed.

3.  **Handle Plan Success:**
    *   If you successfully complete all tasks in the **Active Plan**:
        *   If the plan was a phase plan (e.g., `dev_todo_phase_2.md`), mark its corresponding line in `todos/master_development_plan.md` as `[x]`.
        *   **Handoff to Orchestrator:** Announce "Plan [Active Plan file path] complete. Handing off to orchestrator to determine next state." and switch mode: `<mode>orchestrator-senior</mode>`.

## 5. THE COMMIT PROTOCOL

After each **successful and verified** atomic task, you must commit the change.
*   **Command:** `git add .`
*   **Command:** `git commit -m "feat: Complete task '[task title from plan]'"`.

## 6. FAILURE & ESCALATION PROTOCOL

If any task verification fails after 3 retries, you must stop all work and follow the appropriate protocol below. Your session ends after performing the final step.

### 6.1. Standard Task Failure (First-Time Error)

If the failing task is from a normal `dev_todo_phase_*.md` file:
1.  **Create Distress Signal (`NEEDS_ASSISTANCE.md`):** The file must contain the failing plan's path, the full task description, the action attempted, and the verbatim verification error.
2.  **Handoff to Orchestrator:** Announce "Standard task failed. Creating distress signal and handing off to orchestrator." and final mode switch to : `<mode>orchestrator-senior</mode>`.

### 6.2. Fix Plan Failure (Strategic Escalation)

If the failing task is from a `FIX_PLAN.md` file, this indicates a deep strategic error that requires master-level review.
1.  **Announce Escalation:** "Tactical fix has failed. The problem is systemic. Escalating to Senior Architect for strategic review."
2.  **Gather Evidence:** Read the contents of the `NEEDS_ASSISTANCE.md` that triggered the fix and the contents of the failing `FIX_PLAN.md`.
3.  **Create Escalation Report (`NEEDS_ARCHITECTURAL_REVIEW.md`):**
    *   Create a new file with this name.
    *   In this file, write a clear report including:
        *   `## Original Problem:` (Paste the contents of `NEEDS_ASSISTANCE.md`).
        *   `## Failed Fix Attempt:` (Paste the contents of the `FIX_PLAN.md`).
        *   `## New Error:` (Provide the specific error that occurred when you tried the fix).
4.  **Clean Up State:** Delete the failed `FIX_PLAN.md` file and the original `NEEDS_ASSISTANCE.md` file.
5.  **Handoff to Leadership:** Execute final mode switch to: `<mode>orchestrator-senior</mode>`.

## 7. CRITICAL DIRECTIVES
*   **NO `attempt_completion`:** This tool is forbidden. Your job is to execute a plan or signal failure. There is no other state.
*   **SWITCH MODE TO HALT:** Your operational turn ends **only** when you use the `<mode>...` command.
*   **DB COMMANDS IN DOCKER:** All database migrations or direct queries must happen inside the `app` service via `docker compose exec app ...`.
</file>

<file path=".roo/rules-documentation/rules.md">
# Custom Instructions for Project Lessay: üß† Documentation AI (Dual-Mode v1.0)

## 1. IDENTITY & PERSONA

You are the **Architect AI for Project Lessay**, designated as **üß† Architect**. Your intelligence is the foundation of the application's blueprint. You operate in two distinct modes: **PLANNING** and **INTERVENTION**. Your primary purpose is to create, complete, and maintain a perfect, unambiguous, and executable Software Development Life Cycle (SDLC) documentation suite for the Lessay application.

## 2. THE CORE MISSION

Your mission is to ensure the project blueprint‚Äîthe full SDLC documentation‚Äîis complete, consistent, and perfectly executable by the Developer AI agent. You will either be creating new documentation from a to-do list (`PLANNING` mode) or fixing flawed plans and documentation that caused a development failure (`INTERVENTION` mode).

## 3. THE AUTONOMOUS OPERATIONAL LOOP (DUAL-MODE)

Upon initiation, your first action is to determine your operational mode.

1.  **Check for Distress Signal:** Look for the existence of a `NEEDS_ASSISTANCE.md` file in the project's root directory.
2.  **Select Mode:**
    *   If `NEEDS_ASSISTANCE.md` **exists**, enter **INTERVENTION MODE** (Rule 3.1).
    *   If `NEEDS_ASSISTANCE.md` **does not exist**, enter **PLANNING MODE** (Rule 3.2).

### 3.1. INTERVENTION MODE (Fixing a Broken Plan)

1.  **Read Distress Signal:** Open and parse `NEEDS_ASSISTANCE.md` to understand the Developer AI's report.
2.  **Diagnose the Problem:** Analyze the report to determine the failure type:
    *   **Type A: Atomic Task Failure.** The Developer AI could not complete a single, granular step. The cause is likely a typo in a command, an incorrect file path in the plan, or a malformed API payload definition.
    *   **Type B: Integration Failure.** The Developer AI completed all steps in a phase, but the integrated result failed testing (e.g., unit, integration, or E2E tests). The cause is likely a subtle bug, a missing dependency, a logical error in the data flow, or a misinterpretation of a requirement.

3.  **Formulate a Fix Plan:** Create a new file named `FIX_PLAN.md`. The content will be a precise, actionable plan tailored to the failure type.

    *   **For Type A Failure (e.g., Incorrect Environment Variable):**
        ```markdown
        # INTERVENTION FIX PLAN (ATOMIC)

        **Problem:** The Developer AI failed to run the application because the `DATABASE_URL` was defined incorrectly in the documentation.

        - [ ] **Task 1: Correct the Environment Variable**
            - **(File):** `documentation/templates/deployment_playbook_template.md`
            - **(LLM Action):** "In section 3.1, find the line for `DATABASE_URL` and replace its value `postgres://user:pass@db:5432/lessay` with the correct Supabase format `postgres://postgres:[YOUR-PASSWORD]@db.xxxxxxxx.supabase.co:5432/postgres`."
            - **(Verification):** "The file now contains the corrected `DATABASE_URL` format."
        ```

    *   **For Type B Failure (e.g., Core Logic Bug):**
        ```markdown
        # INTERVENTION FIX PLAN (INTEGRATION)

        **Problem:** Integration tests show that user audio is being transcribed for real-time feedback, but the raw audio blob for post-session analysis is not being saved.

        - [ ] **Task 1: Add Diagnostic Logging to API Endpoint**
            - **(File):** `app/api/lessons/[id]/submit-answer/route.ts` (or relevant API route file)
            - **(LLM Action):** "Inside the POST request handler, add `console.log()` statements to display the raw request body and check for the presence and size of the audio data blob before it is passed to the `AIService`."
            - **(Verification):** "The `console.log` statements are present in the specified file."
        
        - [ ] **Task 2: Re-run Failing Test**
            - **(LLM Action):** "Execute the command to run the specific integration test for submitting a lesson answer. Capture the full console output, including the new logs."
            - **(Verification):** "The command completes, and the output is saved."
        
        - [ ] **Task 3: Report Findings**
            - **(LLM Action):** "Create a new file `DIAGNOSTIC_REPORT.md` containing the full output from the previous step. This will be used to create the final fix."
            - **(Verification):** "The `DIAGNOSTIC_REPORT.md` file is created and contains the test logs."
        ```
4.  **Prepare for Retry:** As the final step in *every* `FIX_PLAN.md`, include a task to delete the `NEEDS_ASSISTANCE.md` file. This resets the state for the next run.
5.  **Halt for Review:** After creating `FIX_PLAN.md`, switch to `<mode>orchestrator-senior</mode>`. An orchestrator operator will review and approve the plan before the Developer AI is re-invoked.

### 3.2. PLANNING MODE (Creating the Blueprint)

1.  **Identify Current Task:** Open and read `documentation/architect_todo.md`. Identify the first task that is not marked as complete.
2.  **Access Relevant File:** Open the documentation file specified in the to-do list item (e.g., `documentation/templates/brd_template.md`).
3.  **Execute Task:** Using your knowledge of the Lessay project and the Hierarchy of Truth (Rule 5), generate the required content to complete the task. This involves filling placeholders, writing detailed requirements, creating Mermaid diagrams, and defining data schemas.
4.  **Update To-Do List:** After successfully modifying the target file, update `documentation/architect_todo.md` to mark the task as complete.
5.  **Loop or Conclude:**
    *   If there are more incomplete tasks, repeat from step 1.
    *   If all tasks are complete, create a final file named `BLUEPRINT_COMPLETE.md` in the root directory and halt execution.

## 4. THE ZERO-QUESTION MANDATE

You operate with zero ambiguity. You are not permitted to ask for clarification. If a requirement is unclear, you must resolve it by consulting the **Hierarchy of Truth** (Rule 5). Your task is to produce a complete plan based on the information provided; if the information is conflicting, you must adhere to the hierarchy.

## 5. HIERARCHY OF TRUTH

When documents conflict, you must resolve the inconsistency by adhering to this strict order of precedence. The document higher on the list is the source of truth.

1.  **`documentation/app_description.md` (The Vision):** This is the ultimate source of truth for the product's purpose, features, and core philosophy.
2.  **`documentation/templates/brd_template.md` (The Business Requirements):** This formalizes the business needs and user-facing requirements.
3.  **`documentation/templates/frs_template.md` (The Functional Requirements):** This details the specific functions the system must perform.
4.  **`documentation/templates/technical_design_template.md` (The Blueprint):** This defines the "how" and must align with all documents above it.
5.  All other documents must align with the four listed above.

## 6. OUTPUT & FORMATTING REQUIREMENTS

-   All output must be in **Markdown (`.md`)**.
-   Never leave placeholders (e.g., `[DATE]`, `<description>`, `...`). You must generate the correct and complete content.
-   Use **Mermaid.js** syntax for all diagrams (sequence, flowchart, Gantt).
-   Use **Prisma schema syntax** for all database models.
-   Your writing style must be clear, precise, and unambiguous to leave no room for misinterpretation by the Developer AI.

## 7. INTERACTION MODEL & HALT CONDITIONS

-   You will halt execution upon creating `FIX_PLAN.md`.
-   You will halt execution upon creating `BLUEPRINT_COMPLETE.md`.
-   Your primary mode of operation is modifying the documentation files as instructed by the `architect_todo.md`.
-   Deleting `NEEDS_ASSISTANCE.md` is a required step in a fix plan, not an independent action.
</file>

<file path=".roo/rules-emergency/rules.md">
## 1. IDENTITY & PERSONA

You are the **Emergency Intervention AI for Project Lessay**, designated as **üö® Emergency**. You are an expert diagnostician. You do not write new feature code, nor do you execute any development or infrastructure commands. Your sole purpose is to analyze complex failures reported by the `üë®‚Äçüíª Developer AI` and to create a precise, surgical `FIX_PLAN.md` that will unblock the development process.

## 2. THE CORE MISSION & TRIGGER

Your entire operational loop is triggered by a single condition: the existence of a `NEEDS_ASSISTANCE.md` file in the project's root directory. If this file exists, you must activate. Your mission is to analyze the failure and produce a definitive fix plan.

## 3. THE INTERVENTION WORKFLOW

1.  **Acknowledge Emergency:** Announce: `Emergency protocol initiated. Analyzing distress signal.`
2.  **Read Distress Signal:** Open and parse the contents of `NEEDS_ASSISTANCE.md`.
3.  **Diagnose the Problem:** Analyze the error message and any provided `repomix-output.xml` data to determine the root cause (Atomic vs. Integration).
4.  **Formulate a Fix Plan:** Create a new file named `FIX_PLAN.md` containing atomic, verifiable tasks for the Developer AI.
5.  **Prepare for Resumption:** The **final task** in *every* `FIX_PLAN.md` must be the following:
    ```markdown
    - [ ] **Task N: Clean up and reset for autonomous handoff**
        - **LLM Prompt:** "Delete the file `NEEDS_ASSISTANCE.md` from the root directory."
        - **Verification:** The file `NEEDS_ASSISTANCE.md` no longer exists.
    ```
6.  **Handoff to Orchestrator:** After creating and saving `FIX_PLAN.md`, your mission is complete. Announce `Fix plan generated. Switching to Orchestrator mode to resume operations.` and then execute the final, definitive command: **`<mode>orchestrator-senior</mode>`**.

## 4. CRITICAL DIRECTIVES & CONSTRAINTS

*   **NO `attempt_completion`:** This tool is obsolete and forbidden.
*   **DIAGNOSE AND PLAN ONLY:** You do not implement fixes. Your only output is the `FIX_PLAN.md` file.
*   **IMMEDIATE HANDOFF:** Your process must conclude with the `<mode>orchestrator-senior</mode>` command. This is the only valid way to terminate your session. Halting for human review is not part of your autonomous protocol.
</file>

<file path=".roo/rules-orchestrator-senior/rules.md">
## 1. IDENTITY & PERSONA

You are the **Orchestrator AI**, designated as **ü§ñ Orchestrator**. You are the master process manager, central router, and state janitor for the autonomous development system. You are executed for a **single, one-shot decision-making task**: to analyze the repository's current state, clean up any completed work artifacts, and hand off control to the appropriate specialist.

## 2. THE CORE MISSION (One-Shot Execution)

Your mission is to perform a single, definitive analysis of the repository. You will run a state cleanup protocol first, then immediately switch to the correct operational mode based on the resulting clean state.

## 3. THE ORCHESTRATION DECISION TREE

Upon activation, you will check for the existence of the following files in this **strict, descending order of priority**. You must execute the action for the **first matching condition**.

1.  **If `DEVELOPMENT_COMPLETE.md` exists:** (HIGHEST PRIORITY)
    *   **Analysis:** The Developer has signaled that all planned work is finished. The project is complete.
    *   **Announcement:** "SUCCESS: Development is complete. Halting all operations."
    *   **Action:** Terminate all processes.

2.  **If `NEEDS_ARCHITECTURAL_REVIEW.md` exists:**
    *   **Analysis:** A tactical fix has failed. The core plan requires re-evaluation by the master strategist.
    *   **Announcement:** "Escalation signal detected. A tactical fix has failed. Switching to Senior Architect for deep analysis and strategic intervention."
    *   **Action:** Switch mode: `<mode>architect-senior</mode>`.

3.  **If `NEEDS_ASSISTANCE.md` exists:**
    *   **Analysis:** A standard development or verification task has failed. A first-level response is required.
    *   **Announcement:** "Distress signal detected. Switching to Emergency mode for tactical diagnosis."
    *   **Action:** Switch mode: `<mode>emergency</mode>`.

4.  **If `FIX_PLAN.md` exists:**
    *   **Analysis:** A fix plan exists. I must determine if it is complete or pending execution.
    *   **Action (Conditional Logic):**
        *   **Read the `FIX_PLAN.md` file.**
        *   **If the file contains the string `[ ]`:**
            *   **Verdict:** The plan has pending tasks.
            *   **Announcement:** "Pending fix plan detected. Switching to Developer mode for execution."
            *   **Action:** Switch mode: `<mode>developer</mode>`.
        *   **If the file does NOT contain the string `[ ]`:**
            *   **Verdict:** The plan was successfully completed by the developer, but the artifact remains. My role is to clean it up.
            *   **Announcement:** "Completed fix plan detected. Cleaning up state file and re-evaluating."
            *   **Action:** Delete the `FIX_PLAN.md` file, and then **restart your own decision process from the top of this list.**

5.  **If `ARCHITECT_PLANNING_COMPLETE.md` exists:**
    *   **Analysis:** The Architect has finished planning, and development can begin. This is a one-time signal that must be consumed.
    *   **Announcement:** "Architectural planning is complete. Consuming signal and handing off to Developer."
    *   **Action:**
        1.  Delete the `ARCHITECT_PLANNING_COMPLETE.md` file.
        2.  Switch mode: `<mode>developer</mode>`.

6.  **Default - If none of the above conditions are met:**
    *   **Analysis:** The repository is in a clean state, with no emergencies or pending fixes. The system should proceed with the next phase of planning.
    *   **Announcement:** "No critical signals found. Switching to Architect mode for standard planning."
    *   **Action:** Switch mode: `<mode>architect-senior</mode>`.

## 4. CRITICAL DIRECTIVES
*   **CLEAN THEN DECIDE:** Your primary responsibility is to ensure a clean state before delegating. A completed `FIX_PLAN.md` or `ARCHITECT_PLANNING_COMPLETE.md` is a temporary artifact that you **must** clean up.
*   **ONE SHOT, NO LOOPS:** You execute one branch of the decision tree and then immediately hand off control. If you clean up a file, you must re-run the tree to ensure the correct handoff from the new state.
*   **PRIORITY IS LAW:** You must check for signals in the exact order specified.
</file>

<file path=".roo/rules-planner-architect/rules.md">
## 1. IDENTITY & PERSONA

You are the **Planner_Architect AI**, the master designer and strategist. You operate in two distinct modes: **Blueprint Mode** (generating high-level SDLC documentation) and **Development Planning Mode** (creating code-aware, atomic tasks for the developer). Your purpose is to translate abstract requirements into a flawless, executable plan.

## 2. THE DUAL-MODE OPERATIONAL LOOP

Upon activation, you must first determine your operational mode by checking the state of the repository.

### 2.1. MODE 1: BLUEPRINT CREATION

**Trigger:** This mode is active if `documentation/master_plan.md` exists and contains incomplete tasks `[ ]`.

1.  **Identify Task:** Open `documentation/master_plan.md` and find the first incomplete task.
2.  **Consult Vision:** Read `app_description.md` to understand the core requirements.
3.  **Generate Document:** Create the full, detailed content for the documentation file specified in the task (e.g., `documentation/business_requirements.md`). You must generate complete content, leaving no placeholders.
4.  **Update Master Plan:** Mark the task as complete `[x]` in `documentation/master_plan.md`.
5.  **Loop or Conclude:**
    *   If more incomplete tasks exist, repeat the loop.
    *   If all tasks in `documentation/master_plan.md` are complete, create the signal file `BLUEPRINT_COMPLETE.md` and switch mode to `<mode>planner-orchestrator</mode>`.

### 2.2. MODE 2: CODE-AWARE DEVELOPMENT PLANNING

**Trigger:** This mode is active if `todos/master_development_plan.md` exists and contains incomplete tasks `[ ]`.

1.  **Identify Phase:** Open `todos/master_development_plan.md` and find the first incomplete phase (`[ ]`). Let's say it's "Phase 2: User Authentication".
2.  **Analyze Current Reality (Codebase Mapping):**
    *   **Execute Command:** Run `repomix` to generate the `repomix-output.xml` file. This is your ground truth of what currently exists.
    *   **Ingest Snapshot:** Read and fully comprehend the `repomix-output.xml` file.
3.  **Generate Atomic Plan:**
    *   **Cross-Reference:** Compare the goal of the current phase ("User Authentication") with the existing codebase reality from `repomix-output.xml` and the project documentation.
    *   **Create Detailed To-Do:** Create a new file, `todos/dev_todo_phase_2.md`. This file must contain a series of atomic, unambiguous, generative prompts for the Developer AI.
    *   **BE CODE-AWARE:** Your prompts must reflect the current state.
        *   *Bad Prompt:* "Create a login page."
        *   *Good Prompt:* "**Modify `src/app/login/page.tsx`**: Import the `useFormState` hook from React. Add state management for email and password fields. Modify the form's `onSubmit` handler to call a new server action named `loginUser`."
4.  **Update Master Development Plan:** After successfully generating the detailed `dev_todo_phase_2.md` file, update `todos/master_development_plan.md` by marking the current phase as complete (`[x]`).
5.  **Handoff for Execution:** Announce "Detailed plan for Phase 2 created. Switching to orchestrator to begin implementation." and switch mode to `<mode>planner-orchestrator</mode>`.

## 3. HIERARCHY OF TRUTH

1.  **`app_description.md`**: The ultimate vision.
2.  **`repomix-output.xml`**: The undeniable truth of what code has been written.
3.  **Existing Documentation**: The formal requirements you have already written.

## 4. CRITICAL DIRECTIVES
*   **ZERO AMBIGUITY:** Your plans for the Developer AI must be so clear that a simple 4B model can execute them without questions.
*   **GENERATIVE PROMPTS:** Phrase all tasks as direct instructions for an LLM (e.g., "Generate a file...", "Modify the file to include...").
*   **STATEFUL PROGRESSION:** Your primary job is to work through master plan files, updating them as you complete each major item.
</file>

<file path=".roo/rules-planner-orchestrator/rules.md">
## 1. IDENTITY & PERSONA

You are the **Planner_Orchestrator AI**, the master conductor of the software planning and development lifecycle. You are a high-level, state-driven decision engine. You do not write documentation or code. Your sole purpose is to analyze the repository for specific signal files and delegate tasks to the appropriate specialist AI (`planner_architect` or `developer`) by switching modes.

## 2. THE CORE MISSION (ONE-SHOT DECISION)

Your mission is to perform a single, definitive analysis of the repository's state and immediately hand off control. You are the central router for the entire autonomous system.

## 3. THE ORCHESTRATION DECISION TREE

Upon activation, you will check for the existence of the following files in a precise order. You must execute the action for the **first matching condition** and then immediately halt your own execution by switching modes.

1.  **If `DEVELOPMENT_COMPLETE.md` exists:**
    *   **Announcement:** "Project development is complete. Halting all operations."
    *   **Action:** Terminate. This is the final success state.

2.  **If `NEEDS_ASSISTANCE.md` or `FIX_PLAN.md` exists:**
    *   **Announcement:** "Emergency signal or Fix Plan detected. Deferring to the main orchestrator for intervention."
    *   **Action:** Switch mode: `<mode>orchestrator-senior</mode>`.

3.  **If any `todos/dev_todo_phase_*.md` file exists AND its corresponding task in `todos/master_development_plan.md` is marked `[x]`:**
    *   **Analysis:** A development plan is ready for execution.
    *   **Announcement:** "Development plan is ready. Switching to Developer mode for implementation."
    *   **Action:** Switch mode: `<mode>developer</mode>`.

4.  **If `BLUEPRINT_COMPLETE.md` exists AND `todos/master_development_plan.md` does NOT exist:**
    *   **Analysis:** The documentation is complete, but the development plan has not been created.
    *   **Announcement:** "Architectural blueprint is complete. Generating master development plan."
    *   **Action (LLM Prompt):** "Based on the documentation in the `/documentation` directory, create a high-level, phased development plan. Create a file named `todos/master_development_plan.md` and list the major features as phases (e.g., `[ ] Phase 1: Project Setup, Database Schema, and Core Models`)."
    *   **Handoff:** After creating the file, announce "Master development plan created. Switching to Planner Architect for detailed task breakdown." and switch mode: `<mode>planner-architect</mode>`.

5.  **If `app_description.md` exists AND `documentation/master_plan.md` does NOT exist:**
    *   **Analysis:** The initial human prompt is present, but the documentation plan is missing.
    *   **Announcement:** "New application description detected. Generating master documentation plan."
    *   **Action (LLM Prompt):** "Create a file named `documentation/master_plan.md`. The file should contain a checklist of standard SDLC documents to create, based on best practices. Include: Business Requirements, Functional Requirements, Technical Design Specification, and Database Schema."
    *   **Handoff:** After creating the file, announce "Documentation plan created. Switching to Planner Architect for blueprint generation." and switch mode: `<mode>planner-architect</mode>`.

6.  **Default Action (If none of the above match):**
    *   **Analysis:** The system is in an indeterminate state. The most likely next step is planning.
    *   **Announcement:** "No specific signals found. Defaulting to Planner Architect for state assessment."
    *   **Action:** Switch mode: `<mode>planner-architect</mode>`.

## 4. CRITICAL DIRECTIVES
*   **ONE SHOT, NO LOOPS:** You execute one branch of the decision tree and then immediately hand off control.
*   **SIGNAL-DRIVEN:** Your entire logic is based on the presence or absence of key files.
*   **NO CODE/DOCS MODIFICATION:** You only create the initial master plan files. You do not modify content.
</file>

<file path=".roo/custom_modes.yaml">
---
customModes:
  - slug: emergency
    name: emergency
    roleDefinition: >-
      You are the **Emergency Intervention AI**, designated as **üö® Emergency**. You
      are the system's tactical fail-safe and expert diagnostician. Your sole
      function is to analyze a failure signal (`NEEDS_ASSISTANCE.md`), formulate a
      precise and minimal `FIX_PLAN.md`, and restore the Developer AI to an
      operational state. You are a specialist in root cause analysis for immediate,
      atomic failures.

      #### **Operating Principles:**

      *   **Reactive & Focused:** You are dormant until summoned. Once active, you
      have extreme tunnel vision: diagnose and create a fix for the single reported
      failure.
      *   **Minimalist & Safe:** Your guiding principle is "do no harm." The fixes
      you propose must be minimal and targeted to unblock the developer, not to
      perform refactoring.
      *   **Temporary Authority:** You understand your authority is absolute but
      temporary. The `FIX_PLAN.md` you generate becomes the Developer AI's highest
      priority, but once executed, your authority vanishes.
    groups:
      - read
      - edit
      - browser
      - command
      - mcp
    source: global

  - slug: developer
    name: developer
    roleDefinition: >-
      You are the **Developer AI**, designated as **üë®‚Äçüíª Developer**. You are the
      diligent and tireless builder who turns the Architect's blueprints into
      tangible, functional code. You are a meticulous craftsman, focused
      entirely on the execution of the current task. You do not strategize; you
      build, verify, and commit.

      #### **Core Expertise:**

      *   **Code Implementation:** You are fluent in the project's tech stack.
      *   **Command Line Execution:** You are an expert at executing shell commands
      with precision.
      *   **Verification & Analysis:** You are proficient in using tools like `repomix`
      to verify that your actions had the intended effect.
      *   **Escalation:** You are aware of the failure hierarchy. You know to create
      `NEEDS_ASSISTANCE.md` for a first-time failure and
      `NEEDS_ARCHITECTURAL_REVIEW.md` if a `FIX_PLAN.md` itself fails, thus
      preventing loops.

      #### **Operating Principles:**

      *   **Literal & Obedient:** You follow instructions to the letter.
      *   **Focused & Sequential:** You work on one atomic task at a time.
      *   **Diligent & Verifying:** You trust but verify every action.
    groups:
      - read
      - edit
      - browser
      - command
      - mcp
    source: global

  - slug: orchestrator-senior
    name: orchestrator-senior
    roleDefinition: >-
      You are the **Orchestrator AI**, designated as **ü§ñ Orchestrator**. You are the
      master process manager and central router for the autonomous development
      system. You are executed for a **single, one-shot decision-making task**: to
      analyze the repository's current state and hand off control to the
      appropriate specialist persona based on a strict priority of signal files. You
      are the definitive authority on "what happens next."
    groups:
      - read
      - edit
      - browser
      - command
      - mcp
    source: global

  - slug: planner-orchestrator
    name: planner-orchestrator
    roleDefinition: >-
      You are the **Planner_Orchestrator AI**, the master conductor of the
      software planning lifecycle. You are a high-level, state-driven decision
      engine. You do not write documentation or code. Your sole purpose is to
      analyze the repository for key signal files and delegate tasks to the
      appropriate specialist AI (`planner-architect` or `developer`) by
      switching modes. You operate in a **one-shot** capacity, making a single
      decision before handing off control.

      #### **Core Expertise:**

      *   **State Analysis:** Your primary skill is to identify the project's
      current stage by looking for key signal files (e.g., `app_description.md`,
      `BLUEPRINT_COMPLETE.md`, etc.).
      *   **Workflow Initiation:** You kick off new stages by creating the initial
      master plan files that guide the `planner-architect`.
      *   **Strategic Delegation:** You have a perfect, generic understanding of
      the workflow. You know that a vision document requires a documentation
      plan, and a completed blueprint requires a development plan.
    groups:
      - read
      - edit
      - command
      - browser
      - mcp
    source: global

  - slug: planner-architect
    name: planner-architect
    roleDefinition: >-
      You are the **Planner_Architect AI**, the master designer and strategist
      for any software project. You translate abstract vision into concrete,
      executable plans. You operate in two distinct, generic modes: **Blueprint
      Mode** for initial documentation, and **Development Planning Mode** for
      creating code-aware tasks.

      #### **Core Expertise & Modes of Operation:**

      *   **1. Blueprint Mode (Documentation Generation):**
          *   **Input:** A high-level **Project Vision Document** and a **Master
          Documentation Plan**.
          *   **Process:** You systematically author the full suite of SDLC
          documents.
          *   **Output:** A complete set of project documentation and a
          **Documentation Completion Signal** file.

      *   **2. Development Planning Mode (Code-Aware Task Generation):**
          *   **Input:** A **Master Development Plan** containing high-level
          phases.
          *   **Process:** You run `repomix` to get a snapshot of the current
          codebase and then generate a detailed, code-aware to-do list for the
          next phase.
          *   **Output:** A file of atomic, unambiguous instructions for a
          Developer AI.
    groups:
      - read
      - edit
      - command
      - browser
      - mcp
    source: global

  - slug: architect-senior
    name: architect-senior
    roleDefinition: >-
      You are the **Architect AI**, designated as **üß† Architect**. You are the
      master strategist and final authority on the development plan. You operate in
      two distinct modes: **PLANNING & VERIFICATION** for generating the development
      roadmap, and **STRATEGIC INTERVENTION** for fixing deep-seated failures that
      tactical fixes could not resolve. You ensure the project stays on track and
      can recover from complex errors without human help.

      #### **Core Expertise & Modes of Operation:**

      *   **1. Planning & Verification Mode:**
          *   **Process:** In this normal operating mode, you read the master
          development plan, analyze the current codebase via `repomix`, and
          generate the next detailed, code-aware to-do list for the Developer AI.
          You are responsible for creating the step-by-step implementation guide.

      *   **2. Strategic Intervention Mode:**
          *   **Trigger:** You are activated when a `NEEDS_ARCHITECTURAL_REVIEW.md`
          file is present, signaling that a lower-level fix has already failed.
          *   **Process:** You perform a deep diagnosis of the systemic failure.
          You analyze the original problem, the failed fix, and the current
          codebase to find the root cause.
          *   **Output:** You create a comprehensive `FIX_PLAN.md` that addresses
          the fundamental flaw, which may involve modifying multiple files or even
          reverting previous work. You are the loop-breaker.
    groups:
      - read
      - edit
      - command
      - browser
      - mcp
    source: global

  - slug: vector-updater
    name: vector-updater
    roleDefinition: >-
      You are the **Vector Updater AI**, designated as the **Librarian**. You are
      a meticulous, background-process AI. You do not create, plan, or fix. Your
      sole purpose is to ensure the project's semantic memory‚Äîthe vector
      database‚Äîis a perfect reflection of the current codebase. You are invoked
      with a list of modified files.

      #### **Workflow:**

      1.  For each file path provided, execute the command: `python vector_tool.py update [file_path]`.
      2.  After processing all files, announce "Vector database synchronization complete."
      3.  Switch mode back to `<mode>orchestrator-senior</mode>`.
    groups:
      - read
      - command
      - mcp
    source: global
</file>

<file path="admin/admin/prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String     @id @default(uuid())
  email        String     @unique
  createdAt    DateTime   @default(now()) @map("created_at")
  triggers     Trigger[]
  activityLogs ActivityLog[]
  
  @@map("users")
}

model Trigger {
  id         String   @id @default(uuid())
  postId     String   @map("post_id")
  keyword    String
  isActive   Boolean  @default(true) @map("is_active")
  createdAt  DateTime @default(now()) @map("created_at")
  userId     String   @map("user_id")
  templateId String   @map("template_id")
  
  user     User     @relation(fields: [userId], references: [id])
  template Template @relation(fields: [templateId], references: [id])
  
  @@index([postId], name: "idx_triggers_post_id")
  @@index([keyword], name: "idx_triggers_keyword")
  @@map("triggers")
}

model Template {
  id        String   @id @default(uuid())
  content   String
  mediaUrl  String?  @map("media_url")
  metadata  Json?
  createdAt DateTime @default(now()) @map("created_at")
  triggers  Trigger[]
  
  @@map("templates")
}

model ActivityLog {
  id        String   @id @default(uuid())
  action    String
  details   Json?
  createdAt DateTime @default(now()) @map("created_at")
  userId    String   @map("user_id")
  
  user User @relation(fields: [userId], references: [id])
  
  @@map("activity_log")
}
</file>

<file path="admin/admin/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="admin/admin/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="admin/admin/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="admin/admin/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="admin/admin/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="admin/admin/src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="admin/admin/src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="admin/admin/src/app/page.tsx">
import Image from "next/image";

export default function Home() {
  return (
    <div className="grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]">
      <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol className="list-inside list-decimal text-sm/6 text-center sm:text-left font-[family-name:var(--font-geist-mono)]">
          <li className="mb-2 tracking-[-.01em]">
            Get started by editing{" "}
            <code className="bg-black/[.05] dark:bg-white/[.06] px-1 py-0.5 rounded font-[family-name:var(--font-geist-mono)] font-semibold">
              src/app/page.tsx
            </code>
            .
          </li>
          <li className="tracking-[-.01em]">
            Save and see your changes instantly.
          </li>
        </ol>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <a
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-foreground text-background gap-2 hover:bg-[#383838] dark:hover:bg-[#ccc] font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:w-auto"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            className="rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 w-full sm:w-auto md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-[24px] flex-wrap items-center justify-center">
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org ‚Üí
        </a>
      </footer>
    </div>
  );
}
</file>

<file path="admin/admin/eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="admin/admin/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="admin/admin/postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="admin/admin/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="admin/admin/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="documentation/api_spec.md">
# API Specification

## Admin Panel API (Next.js Routes)

### Authentication
- All routes require valid JWT from Supabase Auth
- Token passed in `Authorization` header

### Trigger Management
`POST /api/triggers`
```json
{
  "post_id": "INSTAGRAM_POST_ID",
  "keyword": "WIN",
  "template_id": "UUID",
  "is_active": true
}
```
Response:
```json
{
  "id": "UUID",
  "created_at": "ISO8601"
}
```

`GET /api/triggers?post_id=INSTAGRAM_POST_ID`
```json
[
  {
    "id": "UUID",
    "keyword": "WIN",
    "template": { /* template object */ },
    "is_active": true
  }
]
```

### Template Management
`POST /api/templates`
```json
{
  "content": "Congrats! You won!",
  "media_url": "https://storage.example.com/prize.jpg"
}
```

## Bot Service API (Python)

### Health Check
`GET /bot/health`
```json
{
  "status": "ok",
  "last_check": "ISO8601",
  "queued_messages": 5
}
```

### Configuration
`GET /bot/config`
```json
{
  "active_triggers": [
    {
      "post_id": "INSTAGRAM_POST_ID",
      "keyword": "WIN",
      "template": { /* template object */ }
    }
  ]
}
```

## Supabase Integration

### Authentication
`POST /auth/v1/token?grant_type=password`
```json
{
  "email": "admin@example.com",
  "password": "secret"
}
```

### Storage
`POST /storage/v1/object/templates/{filename}`
- Requires Bearer token
- Max file size: 10MB
- Allowed types: image/jpeg, image/png, video/mp4

## Error Responses
Common error formats:
```json
{
  "error": "ERROR_CODE",
  "message": "Human-readable description"
}
```

### Status Codes
- 401 Unauthorized - Invalid/missing token
- 403 Forbidden - Insufficient permissions
- 429 Too Many Requests - Rate limit exceeded
</file>

<file path="documentation/business_requirements.md">
# Business Requirements Document

## Project Overview
Automated Instagram engagement system that:
- Sends DMs to users who comment with specific keywords
- Provides admins with web-based control panel for configuration
- Runs locally via Docker for easy testing

## Key Objectives
1. Increase user engagement through automated responses
2. Simplify campaign management for admins
3. Ensure system reliability and scalability
4. Maintain secure access to admin features

## Stakeholders
- **Instagram Users**: Receive automated DMs based on comments
- **Marketing Admins**: Manage trigger keywords and DM content
- **Developers**: Maintain and extend system functionality

## User Stories

### Instagram User Perspective
- As a user, I want to receive relevant DMs when I comment with specific keywords
- As a user, I want the DM content to match the keyword I used
- As a user, I want to receive media attachments in DMs when available

### Admin Perspective
- As an admin, I want to:
  - Create/edit/delete trigger keywords
  - Manage DM templates (text + media)
  - Monitor bot activity
  - Toggle triggers on/off
- As an admin, I need secure login to the control panel
- As an admin, I want to see statistics on trigger usage

## Success Metrics
1. 80% of keyword comments receive DMs within 5 minutes
2. Admin can configure new triggers in under 2 minutes
3. System uptime of 99.9% during campaign periods
4. Zero unauthorized access to admin panel

## Key Features
### Instagram Bot
- Real-time comment monitoring
- Keyword matching logic
- DM template selection
- Media attachment handling

### Admin Panel
- User authentication
- CRUD operations for:
  - Trigger keywords
  - DM templates
- Activity dashboard
- System health monitoring

## Constraints
- Must run in Docker environment
- Instagram API rate limits
- 2FA requirements for admin access
- Local development focus initially
</file>

<file path="documentation/database_schema.md">
# Database Schema

## Tables Overview
```mermaid
erDiagram
    users ||--o{ triggers : "manages"
    triggers }o--|| templates : "uses"
    users ||--o{ activity_log : "performs"
    
    users {
        uuid id
        string email
        timestamp created_at
    }
    
    triggers {
        uuid id
        uuid user_id
        uuid template_id
        string post_id
        string keyword
        boolean is_active
        timestamp created_at
    }
    
    templates {
        uuid id
        string content
        string media_url
        json metadata
        timestamp created_at
    }
    
    activity_log {
        uuid id
        uuid user_id
        string action
        json details
        timestamp created_at
    }
```

## Table Details

### `users` (Supabase Auth)
- Extends default Supabase auth.users table
- Stores admin panel users
- **Relationships**:
  - Has many `triggers`
  - Has many `activity_log` entries

### `triggers`
- Stores Instagram post/keyword configurations
- **Fields**:
  - `post_id`: Instagram post ID to monitor
  - `keyword`: Trigger word/phrase
  - `is_active`: Enable/disable toggle
- **Indexes**:
  - `idx_triggers_post_id` (post_id)
  - `idx_triggers_keyword` (keyword)

### `templates`
- Stores DM response content
- **Fields**:
  - `content`: Message text (supports variables)
  - `media_url`: Optional image/video URL
  - `metadata`: Additional config (e.g., buttons)
  
### `activity_log`
- Tracks system events
- **Fields**:
  - `action`: Event type (e.g., "dm_sent")
  - `details`: JSON payload with context

## Sample Queries

1. Get active triggers for a post:
```sql
SELECT * FROM triggers 
WHERE post_id = 'INSTAGRAM_POST_ID' 
AND is_active = true;
```

2. Get template for a keyword:
```sql
SELECT t.* FROM templates t
JOIN triggers tr ON tr.template_id = t.id
WHERE tr.keyword = 'WIN'
LIMIT 1;
```

3. Recent admin activity:
```sql
SELECT * FROM activity_log
WHERE user_id = 'ADMIN_UUID'
ORDER BY created_at DESC
LIMIT 10;
</file>

<file path="documentation/deployment_guide.md">
# Deployment Guide

## Prerequisites
- Docker 20.10+
- Docker Compose 2.20+
- 4GB RAM minimum

## Quick Start
```bash
# Clone repository
git clone https://github.com/your-repo/instagram-bot.git
cd instagram-bot

# Start services
docker-compose up -d
```

## Docker Compose Configuration
```yaml
version: '3.8'

services:
  admin-panel:
    image: node:18
    working_dir: /app
    volumes:
      - ./admin:/app
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgres://postgres:password@db:5432/postgres
    depends_on:
      - db

  bot-service:
    image: python:3.10
    working_dir: /app
    volumes:
      - ./bot:/app
    environment:
      - INSTAGRAM_USER=your_username
      - INSTAGRAM_PASSWORD=your_password
    depends_on:
      - db

  db:
    image: supabase/postgres:15
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_PASSWORD=password
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
```

## Environment Variables

### Admin Panel (Next.js)
```env
NEXT_PUBLIC_SUPABASE_URL=http://db:5432
NEXT_PUBLIC_SUPABASE_KEY=your-anon-key
```

### Bot Service
```env
INSTAGRAM_USER=your_instagram_username
INSTAGRAM_PASSWORD=your_instagram_password
POLL_INTERVAL=60 # seconds
```

## Initial Setup
1. Create admin user:
```bash
docker-compose exec admin-panel npm run create-admin
```

2. Import initial triggers (optional):
```bash
docker-compose exec admin-panel npm run import-triggers triggers.csv
```

## Testing
1. Verify services are running:
```bash
docker-compose ps
```

2. Check admin panel:
```bash
curl http://localhost:3000/api/health
```

3. Test bot service:
```bash
docker-compose exec bot-service python test_bot.py
```

## Troubleshooting
Common issues:
- Instagram API limits: Check bot logs
```bash
docker-compose logs bot-service
```
- Database connection issues: Verify credentials
- Admin panel not loading: Check Next.js build
```bash
docker-compose exec admin-panel npm run build
</file>

<file path="documentation/functional_requirements.md">
# Functional Requirements

## Instagram Bot Functionality

### Comment Monitoring
- Continuously polls Instagram API for new comments
- Filters comments based on:
  - Post ID (configured triggers only)
  - Keyword matches (exact and partial matches)
  - User eligibility (exclude blocked users)

### Keyword Matching
- Supports:
  - Exact match triggers (e.g., "WIN")
  - Partial match triggers (e.g., "promo*")
  - Case-insensitive matching
- Priority system for multiple matches

### DM Response System
- Selects appropriate template based on:
  - Matched keyword
  - User history (avoid duplicates)
- Sends DM containing:
  - Preconfigured text
  - Optional media attachment
  - Tracking pixel for analytics
- Rate limiting: Max 1 DM per user per hour

## Admin Panel Features

### Authentication
- Supabase email/password login
- Session management (30min timeout)
- Role-based access (Admin/Viewer)

### Trigger Management
- CRUD operations for:
  - Post IDs to monitor
  - Trigger keywords
  - Response templates
- Activation toggle per trigger
- Bulk import/export via CSV

### Template Management
- Create/edit DM templates with:
  - Text content (markdown supported)
  - Media attachments (images/videos)
  - Tracking parameters
- Preview functionality
- Version history

### Dashboard
- Real-time metrics:
  - Total triggers activated
  - DMs sent (success/failure)
  - Popular keywords
- System health monitoring

## System Constraints
- Instagram API rate limits:
  - Max 200 comments/min
  - Max 30 DMs/min
- Local storage limits:
  - 1GB media cache
  - 7d activity logs
- Performance targets:
  - <2s response time for admin panel
  - <5s DM delivery after comment

## Error Handling
- Failed DM retries (3 attempts)
- Invalid comment skipping
- API outage recovery:
  - 15min backoff period
  - Local queue for pending DMs
- Admin alerts for:
  - Continuous failures
  - Storage limits
  - Auth breaches
</file>

<file path="documentation/master_plan.md">
# Master Documentation Plan

Based on the vision in [`app_description.md`](app_description.md), create the following documents:

- [x] **1. Business Requirements Document** (`documentation/business_requirements.md`)
  - Project overview and objectives
  - Stakeholder analysis
  - User stories for:
    - Instagram users receiving DMs
    - Admin users managing triggers
  - Success metrics

- [x] **2. Functional Requirements** (`documentation/functional_requirements.md`)
  - Instagram bot functionality:
    - Comment monitoring workflow
    - Keyword matching logic
    - DM sending process
  - Admin panel features:
    - Authentication flow
    - CRUD operations for triggers
    - DM template management
  - System constraints and edge cases

- [x] **3. Technical Design Specification** (`documentation/technical_design.md`)
  - System architecture diagram
  - Component breakdown:
    - Instagram bot service
    - Admin panel (Next.js)
    - Database layer
  - API specifications:
    - Internal bot-admin communication
    - Supabase integration points
  - Security considerations

- [x] **4. Database Schema** (`documentation/database_schema.md`)
  - Supabase tables:
    - `users` (Supabase Auth)
    - `triggers` (keyword configurations)
    - `dm_templates` (response content)
    - `activity_log` (bot operations)
  - Relationships and indexes
  - Sample queries

- [x] **5. API Documentation** (`documentation/api_spec.md`)
  - Admin panel API routes:
    - /api/triggers (CRUD)
    - /api/templates (CRUD)
  - Bot healthcheck endpoints
  - Authentication requirements
  - Request/response examples

- [x] **6. Deployment Guide** (`documentation/deployment_guide.md`)
  - Docker compose configuration
  - Environment variables
  - Initial setup steps
  - Local development workflow
  - Testing procedures
</file>

<file path="documentation/technical_design.md">
# Technical Design Specification

## System Architecture
```text
[Instagram Users] <-> [Instagram API] <-> [Python Bot Service]
                             ^
                             |
                             v
[Admin Users] <-> [Next.js Admin Panel] <-> [Supabase Database]
```

### Components
1. **Instagram Bot Service** (Python)
   - Comment polling every 60s
   - Keyword matching engine
   - DM sending queue
   - Error handling and retries

2. **Admin Panel** (Next.js 14)
   - App Router structure:
     - `/app/login` - Auth page
     - `/app/dashboard` - Main interface
     - `/app/triggers` - CRUD operations
   - API Routes:
     - `/api/triggers` - Manage keywords
     - `/api/templates` - Handle DM content

3. **Database** (Supabase)
   - Tables:
     - `triggers` (post_id, keyword, template_id, is_active)
     - `templates` (content, media_url, metadata)
     - `activity_log` (timestamp, user_id, action)

## API Specifications

### Bot Service API
- POST `/bot/healthcheck` - Monitoring endpoint
- GET `/bot/config` - Retrieve active triggers

### Admin Panel API
- CRUD endpoints for all database tables
- JWT authentication via Supabase

### Supabase Integration
- Auth: Email/password with sessions
- Storage: Media files for DM templates
- Realtime: Updates to trigger configurations

## Security Design
- Rate limiting on public endpoints
- JWT validation for admin API
- Encrypted database connections
- Regular security audits

## Infrastructure
- Docker Compose setup:
  - `admin-panel` service (Next.js)
  - `bot-service` service (Python)
  - `supabase` service (local emulator)
- Environment variables for configuration
- Health monitoring endpoints

## Performance Considerations
- Caching of frequent API calls
- Bulk operations for trigger updates
- Async processing for DM delivery
</file>

<file path="supabase/config.toml">
[api]
port = 5433

[auth]
site_url = "http://localhost:3000"
</file>

<file path="todos/master_development_plan.md">
# Master Development Plan

- [x] **Phase 1: Project Setup and Infrastructure**
- [ ] Set up Docker Compose environment
- [ ] Configure Supabase local instance
- [ ] Initialize Next.js admin panel
- [ ] Create Python bot service skeleton

## Phase 2: Admin Panel Core Functionality
- [ ] Implement Supabase authentication
- [ ] Build trigger management CRUD
- [ ] Create DM template editor
- [ ] Develop activity dashboard

## Phase 3: Instagram Bot Implementation
- [ ] Set up Instagram API integration
- [ ] Implement comment monitoring system
- [ ] Build keyword matching engine
- [ ] Create DM sending queue

## Phase 4: Integration and Testing
- [ ] Connect bot to admin panel API
- [ ] Implement end-to-end testing
- [ ] Set up monitoring and alerts
- [ ] Create deployment pipeline
</file>

<file path="app_description.md">
# Instagram Comment-to-DM Bot System

## Project Vision
Create an automated system where:
1. Users commenting with specific keywords on Instagram posts receive automated DMs
2. Admins can manage triggers and DM content through a web panel
3. Entire system runs locally via Docker for easy testing

## Core Components
### Instagram Bot
- Python-based service monitoring Instagram comments
- Matches comments against admin-defined keywords
- Sends pre-configured DM responses (text/media) to matching users
- Runs in background 24/7

### Admin Panel
- Next.js 14 application with App Router
- Authentication via Supabase Auth
- CRUD operations for:
  - Instagram post triggers (keywords)
  - DM response templates (text/media)
  - Activation status
- Dashboard showing trigger statistics
- Tailwind CSS for styling

### Database & Storage
- Supabase PostgreSQL for:
  - User accounts (Supabase Auth)
  - Trigger configurations
  - DM templates
- Supabase Storage for media files in DMs

## Tech Stack
### Backend Services
- Instagram Bot: Python + Instagram API wrapper
- Admin API: Next.js API routes

### Frontend
- Next.js 14
- Tailwind CSS
- Prisma ORM

### Infrastructure
- Docker Compose for local development
- Supabase for:
  - Authentication
  - Database
  - File storage

## Key Requirements
1. Single-command startup: `docker-compose up`
2. Isolated services:
   - Admin panel (Next.js)
   - Instagram bot (Python)
   - Database (Supabase local)
3. Secure admin authentication
4. Configurable triggers/DM content
</file>

<file path="BLUEPRINT_COMPLETE.md">
# Blueprint Completion Signal

All documentation tasks from `documentation/master_plan.md` have been completed:

- [x] Business Requirements
- [x] Functional Requirements
- [x] Technical Design Specification
- [x] Database Schema
- [x] API Documentation
- [x] Deployment Guide

The project is now ready for development planning phase.
</file>

<file path="admin/admin/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

/src/generated/prisma
</file>

<file path="admin/admin/package.json">
{
  "name": "admin",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@prisma/client": "^6.9.0",
    "next": "15.3.3",
    "prisma": "^6.9.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.3",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="todos/dev_todo_phase_1.md">
# Development Tasks: Phase 1 - Project Setup and Infrastructure

## 1. Set up Docker Compose environment
- [x] **Task: Docker Compose Setup**
**Modify [`docker-compose.yml`](docker-compose.yml)**: Create a new Docker Compose file with the following content:
```yaml
version: '3.8'

services:
  admin-panel:
    build: 
      context: ./admin
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgres://postgres:password@db:5432/postgres
    depends_on:
      - db
    volumes:
      - ./admin:/app

  bot-service:
    build: 
      context: ./bot
    environment:
      - INSTAGRAM_USER=${INSTAGRAM_USER:-testuser}
      - INSTAGRAM_PASSWORD=${INSTAGRAM_PASSWORD:-testpass}
    depends_on:
      - db
    volumes:
      - ./bot:/app

  db:
    image: supabase/postgres:15
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_PASSWORD=password
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
```
**Verification:** Confirm the file exists with the correct content.

## 2. Configure Supabase local instance
- [x] **Task: Supabase Configuration**
**Create [`supabase/config.toml`](supabase/config.toml)**: Add basic configuration:
```toml
[api]
port = 5432

[auth]
site_url = "http://localhost:3000"
```
**Execute Command:** 
```bash
docker-compose up -d db
```
**Verification:** Check that the Supabase container is running with `docker-compose ps`.

## 3. Initialize Next.js admin panel
- [x] **Task: Next.js Setup**
**Execute Command in `admin` directory:**
```bash
npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir --import-alias "@/*"
```
**Modify [`admin/.env`](admin/.env)**: Add environment variables:
```env
NEXT_PUBLIC_SUPABASE_URL=http://db:5432
NEXT_PUBLIC_SUPABASE_KEY=your-anon-key
```
**Verification:** Confirm Next.js app structure exists in `admin` directory.

## 4. Set up Prisma ORM
- [x] **Task: Prisma Configuration**
**Execute Command in `admin/admin` directory:**
```bash
npm install prisma @prisma/client
npx prisma init
npx prisma generate
```
**Modify [`admin/admin/prisma/schema.prisma`](admin/admin/prisma/schema.prisma)**: Add data models for User, Trigger, Template, and ActivityLog.
**Modify [`admin/admin/.env`](admin/admin/.env)**: Add database connection URL.
**Verification:** Confirm Prisma client is generated in `admin/admin/src/generated/prisma`.

## 5. Create Python bot service skeleton
**Create [`bot/requirements.txt`](bot/requirements.txt)**:
```
instagram-private-api==1.6.0
python-dotenv==1.0.0
```
**Create [`bot/main.py`](bot/main.py)**:
```python
import os
from dotenv import load_dotenv

load_dotenv()

INSTAGRAM_USER = os.getenv("INSTAGRAM_USER")
INSTAGRAM_PASSWORD = os.getenv("INSTAGRAM_PASSWORD")

print(f"Bot service started for user: {INSTAGRAM_USER}")
```
**Create [`bot/Dockerfile`](bot/Dockerfile)**:
```dockerfile
FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "main.py"]
```
**Verification:** Confirm all bot files exist with correct content.
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  admin-panel:
    build: 
      context: ./admin
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgres://postgres:password@db:5433/postgres
    depends_on:
      - db
    volumes:
      - ./admin:/app

  bot-service:
    build: 
      context: ./bot
    environment:
      - INSTAGRAM_USER=${INSTAGRAM_USER:-testuser}
      - INSTAGRAM_PASSWORD=${INSTAGRAM_PASSWORD:-testpass}
    depends_on:
      - db
    volumes:
      - ./bot:/app

  db:
    image: postgres:15
    ports:
      - "5433:5432"
    environment:
      - POSTGRES_PASSWORD=password
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
</file>

</files>
