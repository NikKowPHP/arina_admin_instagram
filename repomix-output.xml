This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    main.yml
.roo/
  rules-architect/
    rules.md
  rules-developer/
    rules.md
  rules-emergency/
    rules.md
  rules-orchestrator/
    rules.md
  rules-product-manager/
    rules.md
  rules-qa-engineer/
    rules.md
  rules-system-supervisor/
    rules.md
  custom_modes.yaml
admin/
  admin/
    prisma/
      schema.prisma
    public/
      file.svg
      globe.svg
      next.svg
      vercel.svg
      window.svg
    src/
      app/
        api/
          bot/
            health/
              route.ts
            healthcheck/
              route.ts
        dashboard/
          triggers/
            page.tsx
          page.tsx
        globals.css
        layout.tsx
        page.tsx
      components/
        ui/
          bar-chart.tsx
          button.tsx
          card.tsx
          line-chart.tsx
          pie-chart.tsx
        bot-health-status.tsx
        chart-controls.tsx
      lib/
        actions.ts
        supabase-provider.tsx
        supabase.ts
        utils.ts
        validators.ts
      types/
        bot-monitor.ts
        supabase.ts
    .gitignore
    eslint.config.mjs
    next.config.ts
    package.json
    postcss.config.mjs
    README.md
    repomix-output.xml
    tsconfig.json
bot/
  __init__.py
  Dockerfile
  instagram_bot.py
  main.py
  requirements.txt
bot-monitor/
  nodejs.d.ts
  service.ts
  types.ts
documentation/
  api_spec.md
  business_requirements.md
  database_schema.md
  deployment_guide.md
  functional_requirements.md
  master_plan.md
  technical_design.md
instagram_bot/
  tests/
    mock_services.py
    test_config.py
  __init__.py
  .env.example
  Dockerfile
  instagram_bot.py
  main.py
  requirements.txt
  test_instagram_bot.py
supabase/
  .gitignore
  config.toml
work_items/
  ticket-01-implement-bot-service.md
.gitignore
app_description.md
current_task.md
dev_todo_item-01.md
dev_todo_phase_2.md
docker-compose.yml
master_development_plan.md
project_manifest.json
QA_APPROVED.md
README.md
setup.py
TECH_LEAD_APPROVED.md
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="QA_APPROVED.md">
# QA Approval

The changes to fix data-fetching bugs in the analytics dashboard have passed the quality audit.

## Verified Fixes:
1. Replaced invalid `lastLogin` field with valid `createdAt` from activity_log
2. Updated template query to use existing `content` field instead of non-existent `name`
3. Confirmed changes align with Prisma schema
4. Verified no breaking changes in related components

The implementation meets quality standards and is ready for deployment.
</file>

<file path="TECH_LEAD_APPROVED.md">
# Tech Lead Approval

The changes to fix the data-fetching bugs in the analytics dashboard have been reviewed and approved.

## Approved Changes:
1. Replaced the non-existent `lastLogin` field with `createdAt` from the `activity_log` table for user activity metrics
2. Updated template usage query to use the existing `content` field instead of the non-existent `name` field
3. Verified changes against the Prisma schema for consistency

The implementation is technically sound and aligns with the project's architecture.
</file>

<file path=".roo/rules-product-manager/rules.md">
## 1. IDENTITY & PERSONA
You are the **Product Manager AI** (ðŸ“ˆ The Clarifier). You are the primary interpreter of the human's vision. Your purpose is to eliminate ambiguity by transforming a high-level description into a definitive, machine-readable specification.

## 2. THE CORE MISSION & TRIGGER
Your mission is to create the project's **source of truth**. You are triggered by the Orchestrator only when `/docs/app_description.md` exists, but `/docs/canonical_spec.md` does not.

## 3. THE CLARIFICATION WORKFLOW
1.  **Acknowledge & Log:** "New project vision detected. I will create the canonical specification."
2.  **Create Directories:** Ensure `/docs/` and `/signals/` exist.
3.  **Read and Deconstruct the Vision:**
    *   Read the full contents of `/docs/app_description.md`.
    *   Perform a semantic analysis to identify all features, user stories, requirements, and constraints.
4.  **Create Canonical Specification:**
    *   Create `/docs/canonical_spec.md`. This file must be a comprehensive, non-ambiguous document detailing the entire project. This is now the project's primary reference.
    *   Create a skeleton `/docs/README.md`.
5.  **Announce & Handoff:**
    *   Create the signal file `/signals/SPECIFICATION_COMPLETE.md`.
    *   Announce: "Canonical specification is complete. Handing off to the Architect for full-scale planning."
    *   Switch mode to `<mode>orchestrator</mode>`.
</file>

<file path=".roo/rules-system-supervisor/rules.md">
## 1. IDENTITY & PERSONA
You are the **System_Supervisor AI** (ðŸ‘‘ Supervisor). You are the ultimate meta-agent that repairs the system's workflow logic. You operate by reading the `project_manifest.json` to find and analyze the system log.

## 2. THE CORE MISSION & TRIGGER
You are activated by the `Orchestrator` during an infinite loop. Your mission is to diagnose the flawed workflow by analyzing the log file and rewrite an agent's rules to correct it.

## 3. THE META-ANALYSIS & REPAIR WORKFLOW

1.  **Read the Manifest:** Read `project_manifest.json` to get the `log_file` path.
2.  **Ingest System State:**
    *   `echo '{"timestamp": "...", "agent": "System_Supervisor", "event": "action_start", "details": "Activated to resolve system-level failure."}' >> [log_file]`

3.  **Perform Root Cause Analysis on the *Workflow*:**
    *   **Analyze the Logs:** Read the `log_file` to trace the sequence of agent handoffs that led to the loop.
    *   **Analyze the Rules:** Read the `.roo/rules-*.md` files for the involved agents.
    *   **Identify & Log the Flaw:** Pinpoint the exact rule conflict causing the failure.
    *   `echo '{"timestamp": "...", "agent": "System_Supervisor", "event": "diagnosis", "details": "Identified logical flaw: [Concise description]"}' >> [log_file]`

4.  **Formulate a Rule-Based Solution:**
    *   Identify the target agent whose rules must be changed.
    *   Draft a new, corrected version of that agent's `rules.md` file.

5.  **Execute the System Refactor:**
    *   **Action:** Replace the content of `[path_to_agent_rules.md]` with the new ruleset.
    *   `echo '{"timestamp": "...", "agent": "System_Supervisor", "event": "action_complete", "details": "Applied fix by rewriting rules for agent: [Agent Name]."}' >> [log_file]`

6.  **Announce Fix & Handoff:**
    *   Announce: "System workflow repaired. I have updated the rules for the `[Agent Name]`. Retrying operation."
    *   Switch mode back to `<mode>orchestrator</mode>`.

## 4. CRITICAL DIRECTIVES
*   You only modify `.md` rule files.
*   Make the smallest, most targeted change possible.
*   You are forbidden from modifying your own `rules.md` file.
*   Explain your reasoning in your announcement and logs.
</file>

<file path="admin/admin/prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String     @id @default(uuid())
  email        String     @unique
  createdAt    DateTime   @default(now()) @map("created_at")
  triggers     Trigger[]
  activityLogs ActivityLog[]
  
  @@map("users")
}

model Trigger {
  id         String   @id @default(uuid())
  postId     String   @map("post_id")
  keyword    String
  isActive   Boolean  @default(true) @map("is_active")
  createdAt  DateTime @default(now()) @map("created_at")
  userId     String   @map("user_id")
  templateId String   @map("template_id")
  
  user     User     @relation(fields: [userId], references: [id])
  template Template @relation(fields: [templateId], references: [id])
  
  @@index([postId], name: "idx_triggers_post_id")
  @@index([keyword], name: "idx_triggers_keyword")
  @@map("triggers")
}

model Template {
  id        String   @id @default(uuid())
  content   String
  mediaUrl  String?  @map("media_url")
  metadata  Json?
  createdAt DateTime @default(now()) @map("created_at")
  triggers  Trigger[]
  
  @@map("templates")
}

model ActivityLog {
  id        String   @id @default(uuid())
  action    String
  details   Json?
  createdAt DateTime @default(now()) @map("created_at")
  userId    String   @map("user_id")
  
  user User @relation(fields: [userId], references: [id])
  
  @@map("activity_log")
}
</file>

<file path="admin/admin/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="admin/admin/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="admin/admin/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="admin/admin/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="admin/admin/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="admin/admin/src/app/api/bot/health/route.ts">
import { NextResponse } from 'next/server'
import { BotMonitor } from '@/bot-monitor/service'

// Initialize the bot monitor with the appropriate endpoint
const botMonitor = new BotMonitor('/api/bot/healthcheck', '/path/to/media/cache')

export async function GET() {
  // Start the monitor if it's not already running
  if (!botMonitor.storageCheckInterval) {
    botMonitor.start()
  }

  // Return the current health status
  const healthStatus = botMonitor.getCurrentHealth()

  return NextResponse.json(healthStatus, { status: 200 })
}
</file>

<file path="admin/admin/src/app/api/bot/healthcheck/route.ts">
import { NextResponse } from 'next/server'

export async function POST() {
  // In a real implementation, this would check the bot's health
  // For now, we'll just return a success response
  return NextResponse.json({ status: 'healthy' }, { status: 200 })
}
</file>

<file path="admin/admin/src/app/dashboard/triggers/page.tsx">
import { Button } from '@/components/ui/button'
import { Plus } from 'lucide-react'

export default function TriggersPage() {
  return (
    <div className="p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Trigger Management</h1>
        <Button variant="primary">
          <Plus className="mr-2 h-4 w-4" />
          Create New Trigger
        </Button>
      </div>
      {/* TODO: Add trigger list table */}
    </div>
  )
}
</file>

<file path="admin/admin/src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="admin/admin/src/app/page.tsx">
import Image from "next/image";

export default function Home() {
  return (
    <div className="grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]">
      <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol className="list-inside list-decimal text-sm/6 text-center sm:text-left font-[family-name:var(--font-geist-mono)]">
          <li className="mb-2 tracking-[-.01em]">
            Get started by editing{" "}
            <code className="bg-black/[.05] dark:bg-white/[.06] px-1 py-0.5 rounded font-[family-name:var(--font-geist-mono)] font-semibold">
              src/app/page.tsx
            </code>
            .
          </li>
          <li className="tracking-[-.01em]">
            Save and see your changes instantly.
          </li>
        </ol>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <a
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-foreground text-background gap-2 hover:bg-[#383838] dark:hover:bg-[#ccc] font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:w-auto"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            className="rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 w-full sm:w-auto md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-[24px] flex-wrap items-center justify-center">
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org â†’
        </a>
      </footer>
    </div>
  );
}
</file>

<file path="admin/admin/src/components/ui/button.tsx">
import { cn } from "@/lib/utils"
import { forwardRef } from "react"

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: "primary" | "secondary" | "outline"
  size?: "sm" | "md" | "lg"
  isLoading?: boolean
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = "primary", size = "md", isLoading, ...props }, ref) => {
    return (
      <button
        className={cn(
          "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring disabled:opacity-50 disabled:pointer-events-none",
          {
            "bg-primary text-primary-foreground hover:bg-primary/90": variant === "primary",
            "bg-secondary text-secondary-foreground hover:bg-secondary/80": variant === "secondary",
            "border border-input hover:bg-accent hover:text-accent-foreground": variant === "outline",
            "h-8 px-3": size === "sm",
            "h-10 px-4": size === "md",
            "h-12 px-6": size === "lg",
          },
          className
        )}
        disabled={isLoading}
        ref={ref}
        {...props}
      >
        {isLoading ? (
          <span className="animate-spin">ðŸŒ€</span>
        ) : (
          props.children
        )}
      </button>
    )
  }
)
Button.displayName = "Button"

export { Button }
</file>

<file path="admin/admin/src/components/ui/card.tsx">
import { cn } from '@/lib/utils'
import { ReactNode } from 'react'

interface CardProps {
  children: ReactNode
  className?: string
}

export function Card({ children, className }: CardProps) {
  return (
    <div className={cn(
      'rounded-lg border bg-card text-card-foreground shadow-sm',
      className
    )}>
      {children}
    </div>
  )
}
</file>

<file path="admin/admin/src/components/ui/line-chart.tsx">
'use client'

import { Line } from 'react-chartjs-2'
import { 
  Chart as ChartJS, 
  CategoryScale, 
  LinearScale, 
  PointElement, 
  LineElement, 
  Title, 
  Tooltip, 
  Legend 
} from 'chart.js'

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
)

type LineChartDataItem = Record<string, unknown>

interface LineChartProps {
  datasets: LineChartDataItem[]
  xAxis: string
  yFields: string[]
  title?: string
  colors?: string[]
}

export function LineChart({ datasets, xAxis, yFields, title, colors }: LineChartProps) {
  const chartData = {
    labels: datasets.map(item => item[xAxis]),
    datasets: yFields.map((field, index) => ({
      label: field,
      data: datasets.map(item => item[field]),
      borderColor: colors?.[index] || 'rgba(59, 130, 246, 0.5)',
      backgroundColor: colors?.[index] || 'rgba(59, 130, 246, 0.2)'
    }))
  }

  const options = {
    responsive: true,
    plugins: {
      legend: {
        position: 'top' as const,
      },
      title: {
        display: !!title,
        text: title,
      },
      tooltip: {
        mode: 'index' as const,
        intersect: false,
      },
    },
    interaction: {
      mode: 'index' as const,
      intersect: false,
    },
  }

  return <Line options={options} data={chartData} />
}
</file>

<file path="admin/admin/src/components/ui/pie-chart.tsx">
'use client'

import { Pie } from 'react-chartjs-2'
import { 
  Chart as ChartJS, 
  ArcElement, 
  Tooltip, 
  Legend 
} from 'chart.js'

ChartJS.register(
  ArcElement,
  Tooltip,
  Legend
)

type PieChartDataItem = Record<string, unknown>

interface PieChartProps {
  datasets: PieChartDataItem[]
  labelField: string
  valueField: string
  title?: string
  colors?: string[]
}

export function PieChart({ datasets, labelField, valueField, title, colors }: PieChartProps) {
  const chartData = {
    labels: datasets.map(item => item[labelField]),
    datasets: [{
      label: valueField,
      data: datasets.map(item => item[valueField]),
      backgroundColor: colors || [
        'rgba(255, 99, 132, 0.5)',
        'rgba(54, 162, 235, 0.5)',
        'rgba(255, 206, 86, 0.5)',
        'rgba(75, 192, 192, 0.5)',
        'rgba(153, 102, 255, 0.5)',
        'rgba(255, 159, 64, 0.5)'
      ],
      borderWidth: 1,
    }]
  }

  const options = {
    responsive: true,
    plugins: {
      legend: {
        position: 'top' as const,
      },
      title: {
        display: !!title,
        text: title,
      },
      tooltip: {
        mode: 'index' as const,
        intersect: false,
      },
    },
  }

  return <Pie options={options} data={chartData} />
}
</file>

<file path="admin/admin/src/components/chart-controls.tsx">
'use client'

interface ChartControlsProps {
  dateRange: string
  onDateRangeChange: (range: string) => void
  chartType: string
  onChartTypeChange: (type: string) => void
  visibleData: string[]
  onVisibleDataChange: (data: string[]) => void
}

export function ChartControls({
  dateRange,
  onDateRangeChange,
  chartType,
  onChartTypeChange,
  visibleData,
  onVisibleDataChange
}: ChartControlsProps) {
  return (
    <div className="space-y-4 p-4 border rounded">
      <div>
        <label className="block text-sm font-medium mb-1">Date Range</label>
        <select
          value={dateRange}
          onChange={(e) => onDateRangeChange(e.target.value)}
          className="w-full p-2 border rounded"
        >
          <option value="7d">Last 7 days</option>
          <option value="30d">Last 30 days</option>
          <option value="90d">Last 90 days</option>
        </select>
      </div>

      <div>
        <label className="block text-sm font-medium mb-1">Chart Type</label>
        <select
          value={chartType}
          onChange={(e) => onChartTypeChange(e.target.value)}
          className="w-full p-2 border rounded"
        >
          <option value="bar">Bar Chart</option>
          <option value="line">Line Chart</option>
          <option value="pie">Pie Chart</option>
        </select>
      </div>

      <div>
        <label className="block text-sm font-medium mb-1">Visible Data</label>
        <div className="space-y-2">
          {['Triggers', 'Users', 'Templates'].map((item) => (
            <label key={item} className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={visibleData.includes(item)}
                onChange={(e) => {
                  const newVisible = e.target.checked
                    ? [...visibleData, item]
                    : visibleData.filter((v) => v !== item)
                  onVisibleDataChange(newVisible)
                }}
                className="rounded"
              />
              <span>{item}</span>
            </label>
          ))}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="admin/admin/src/lib/supabase-provider.tsx">
'use client'

import { createClient } from './supabase'
import { createContext, useContext, useState } from 'react'

const SupabaseContext = createContext(createClient())

export function SupabaseProvider({ children }: { children: React.ReactNode }) {
  const [supabase] = useState(() => createClient())
  
  return (
    <SupabaseContext.Provider value={supabase}>
      {children}
    </SupabaseContext.Provider>
  )
}

export const useSupabase = () => useContext(SupabaseContext)
</file>

<file path="admin/admin/src/lib/utils.ts">
import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="admin/admin/src/lib/validators.ts">
import { z } from 'zod';

export const templateSchema = z.object({
  content: z.string().min(10, "Content must be at least 10 characters"),
  mediaUrl: z.string().url().optional(),
  isActive: z.boolean().default(true)
});
</file>

<file path="admin/admin/src/types/bot-monitor.ts">
export type { BotHealthStatus, ActivityEvent } from '../../../../bot-monitor/types';
</file>

<file path="admin/admin/src/types/supabase.ts">
import { PrismaClient } from '@prisma/client'

export type Database = typeof PrismaClient
export type User = PrismaClient['user']
export type Trigger = PrismaClient['trigger']
export type Template = PrismaClient['template']
export type ActivityLog = PrismaClient['activityLog']
</file>

<file path="admin/admin/eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="admin/admin/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="admin/admin/postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="admin/admin/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="admin/admin/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
prisma/
  schema.prisma
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
src/
  app/
    dashboard/
      page.tsx
    globals.css
    layout.tsx
    page.tsx
  components/
    ui/
      bar-chart.tsx
      card.tsx
  lib/
    actions.ts
    supabase-provider.tsx
    supabase.ts
    utils.ts
  types/
    supabase.ts
.gitignore
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String     @id @default(uuid())
  email        String     @unique
  createdAt    DateTime   @default(now()) @map("created_at")
  triggers     Trigger[]
  activityLogs ActivityLog[]
  
  @@map("users")
}

model Trigger {
  id         String   @id @default(uuid())
  postId     String   @map("post_id")
  keyword    String
  isActive   Boolean  @default(true) @map("is_active")
  createdAt  DateTime @default(now()) @map("created_at")
  userId     String   @map("user_id")
  templateId String   @map("template_id")
  
  user     User     @relation(fields: [userId], references: [id])
  template Template @relation(fields: [templateId], references: [id])
  
  @@index([postId], name: "idx_triggers_post_id")
  @@index([keyword], name: "idx_triggers_keyword")
  @@map("triggers")
}

model Template {
  id        String   @id @default(uuid())
  content   String
  mediaUrl  String?  @map("media_url")
  metadata  Json?
  createdAt DateTime @default(now()) @map("created_at")
  triggers  Trigger[]
  
  @@map("templates")
}

model ActivityLog {
  id        String   @id @default(uuid())
  action    String
  details   Json?
  createdAt DateTime @default(now()) @map("created_at")
  userId    String   @map("user_id")
  
  user User @relation(fields: [userId], references: [id])
  
  @@map("activity_log")
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="src/app/dashboard/page.tsx">
import { BarChart, Card } from '@/components/ui'
import { getAnalytics } from '@/lib/actions'

export default async function DashboardPage() {
  const data = await getAnalytics()
  
  return (
    <div className="p-6 space-y-6">
      <h1 className="text-2xl font-bold">Analytics Dashboard</h1>
      
      <Card>
        <h2 className="text-lg mb-4">Trigger Activity</h2>
        <BarChart
          data={data.triggerUsage}
          xAxis="date"
          yAxis="count"
        />
      </Card>

      {/* Add more chart components */}
    </div>
  )
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { SupabaseProvider } from "@/lib/supabase-provider";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <SupabaseProvider>
          {children}
        </SupabaseProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.tsx">
import Image from "next/image";

export default function Home() {
  return (
    <div className="grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]">
      <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol className="list-inside list-decimal text-sm/6 text-center sm:text-left font-[family-name:var(--font-geist-mono)]">
          <li className="mb-2 tracking-[-.01em]">
            Get started by editing{" "}
            <code className="bg-black/[.05] dark:bg-white/[.06] px-1 py-0.5 rounded font-[family-name:var(--font-geist-mono)] font-semibold">
              src/app/page.tsx
            </code>
            .
          </li>
          <li className="tracking-[-.01em]">
            Save and see your changes instantly.
          </li>
        </ol>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <a
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-foreground text-background gap-2 hover:bg-[#383838] dark:hover:bg-[#ccc] font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:w-auto"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            className="rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 w-full sm:w-auto md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-[24px] flex-wrap items-center justify-center">
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org â†’
        </a>
      </footer>
    </div>
  );
}
</file>

<file path="src/components/ui/bar-chart.tsx">
'use client'

import { Bar } from 'react-chartjs-2'
import { 
  Chart as ChartJS, 
  CategoryScale, 
  LinearScale, 
  BarElement, 
  Title, 
  Tooltip, 
  Legend 
} from 'chart.js'

ChartJS.register(
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend
)

interface BarChartProps {
  data: Array<{[key: string]: any}>
  xAxis: string
  yAxis: string
  title?: string
}

export function BarChart({ data, xAxis, yAxis, title }: BarChartProps) {
  const chartData = {
    labels: data.map(item => item[xAxis]),
    datasets: [{
      label: yAxis,
      data: data.map(item => item[yAxis]),
      backgroundColor: 'rgba(59, 130, 246, 0.5)'
    }]
  }

  const options = {
    responsive: true,
    plugins: {
      legend: {
        position: 'top' as const,
      },
      title: {
        display: !!title,
        text: title,
      },
    },
  }

  return <Bar options={options} data={chartData} />
}
</file>

<file path="src/components/ui/card.tsx">
import { cn } from '@/lib/utils'
import { ReactNode } from 'react'

interface CardProps {
  children: ReactNode
  className?: string
}

export function Card({ children, className }: CardProps) {
  return (
    <div className={cn(
      'rounded-lg border bg-card text-card-foreground shadow-sm',
      className
    )}>
      {children}
    </div>
  )
}
</file>

<file path="src/lib/actions.ts">
import { createClient } from './supabase'

export async function getAnalytics() {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('activity_log')
    .select('*')
    .gte('created_at', new Date(Date.now() - 7 * 86400000).toISOString())
  
  if (error) throw error
  
  // Process data into chart formats
  return {
    triggerUsage: data.map(entry => ({
      date: new Date(entry.created_at).toLocaleDateString(),
      count: entry.action === 'trigger' ? 1 : 0
    }))
  }
}
</file>

<file path="src/lib/supabase-provider.tsx">
'use client'

import { createClient } from './supabase'
import { createContext, useContext, useState } from 'react'

const SupabaseContext = createContext(createClient())

export function SupabaseProvider({ children }: { children: React.ReactNode }) {
  const [supabase] = useState(() => createClient())
  
  return (
    <SupabaseContext.Provider value={supabase}>
      {children}
    </SupabaseContext.Provider>
  )
}

export const useSupabase = () => useContext(SupabaseContext)
</file>

<file path="src/lib/supabase.ts">
import { createBrowserClient } from '@supabase/ssr'
import { Database } from '@/types/supabase'

export function createClient() {
  return createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_KEY!
  )
}
</file>

<file path="src/lib/utils.ts">
import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/types/supabase.ts">
import { PrismaClient } from '@prisma/client'

export type Database = typeof PrismaClient
export type User = PrismaClient['user']
export type Trigger = PrismaClient['trigger']
export type Template = PrismaClient['template']
export type ActivityLog = PrismaClient['activityLog']
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

/src/generated/prisma
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "admin",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@prisma/client": "^6.9.0",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/ssr": "^0.6.1",
    "@supabase/supabase-js": "^2.50.0",
    "next": "15.3.3",
    "prisma": "^6.9.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.3",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

</files>
</file>

<file path="bot-monitor/nodejs.d.ts">
declare namespace NodeJS {
  interface Timeout {
    readonly hasRef: boolean;
    ref(): void;
    unref(): void;
  }
}

declare module 'child_process' {
  export function exec(command: string, callback: (error: Error | null, stdout: string, stderr: string) => void): void;
}

declare module 'util' {
  export function promisify<T extends (...args: any[]) => any>(original: T): (...args: Parameters<T>) => Promise<ReturnType<T>>;
}
</file>

<file path="documentation/api_spec.md">
# API Specification

## Admin Panel API (Next.js Routes)

### Authentication
- All routes require valid JWT from Supabase Auth
- Token passed in `Authorization` header

### Trigger Management
`POST /api/triggers`
```json
{
  "post_id": "INSTAGRAM_POST_ID",
  "keyword": "WIN",
  "template_id": "UUID",
  "is_active": true
}
```
Response:
```json
{
  "id": "UUID",
  "created_at": "ISO8601"
}
```

`GET /api/triggers?post_id=INSTAGRAM_POST_ID`
```json
[
  {
    "id": "UUID",
    "keyword": "WIN",
    "template": { /* template object */ },
    "is_active": true
  }
]
```

### Template Management
`POST /api/templates`
```json
{
  "content": "Congrats! You won!",
  "media_url": "https://storage.example.com/prize.jpg"
}
```

## Bot Service API (Python)

### Health Check
`GET /bot/health`
```json
{
  "status": "ok",
  "last_check": "ISO8601",
  "queued_messages": 5
}
```

### Configuration
`GET /bot/config`
```json
{
  "active_triggers": [
    {
      "post_id": "INSTAGRAM_POST_ID",
      "keyword": "WIN",
      "template": { /* template object */ }
    }
  ]
}
```

## Supabase Integration

### Authentication
`POST /auth/v1/token?grant_type=password`
```json
{
  "email": "admin@example.com",
  "password": "secret"
}
```

### Storage
`POST /storage/v1/object/templates/{filename}`
- Requires Bearer token
- Max file size: 10MB
- Allowed types: image/jpeg, image/png, video/mp4

## Error Responses
Common error formats:
```json
{
  "error": "ERROR_CODE",
  "message": "Human-readable description"
}
```

### Status Codes
- 401 Unauthorized - Invalid/missing token
- 403 Forbidden - Insufficient permissions
- 429 Too Many Requests - Rate limit exceeded
</file>

<file path="documentation/business_requirements.md">
# Business Requirements Document

## Project Overview
Automated Instagram engagement system that:
- Sends DMs to users who comment with specific keywords
- Provides admins with web-based control panel for configuration
- Runs locally via Docker for easy testing

## Key Objectives
1. Increase user engagement through automated responses
2. Simplify campaign management for admins
3. Ensure system reliability and scalability
4. Maintain secure access to admin features

## Stakeholders
- **Instagram Users**: Receive automated DMs based on comments
- **Marketing Admins**: Manage trigger keywords and DM content
- **Developers**: Maintain and extend system functionality

## User Stories

### Instagram User Perspective
- As a user, I want to receive relevant DMs when I comment with specific keywords
- As a user, I want the DM content to match the keyword I used
- As a user, I want to receive media attachments in DMs when available

### Admin Perspective
- As an admin, I want to:
  - Create/edit/delete trigger keywords
  - Manage DM templates (text + media)
  - Monitor bot activity
  - Toggle triggers on/off
- As an admin, I need secure login to the control panel
- As an admin, I want to see statistics on trigger usage

## Success Metrics
1. 80% of keyword comments receive DMs within 5 minutes
2. Admin can configure new triggers in under 2 minutes
3. System uptime of 99.9% during campaign periods
4. Zero unauthorized access to admin panel

## Key Features
### Instagram Bot
- Real-time comment monitoring
- Keyword matching logic
- DM template selection
- Media attachment handling

### Admin Panel
- User authentication
- CRUD operations for:
  - Trigger keywords
  - DM templates
- Activity dashboard
- System health monitoring

## Constraints
- Must run in Docker environment
- Instagram API rate limits
- 2FA requirements for admin access
- Local development focus initially
</file>

<file path="documentation/database_schema.md">
# Database Schema

## Tables Overview
```mermaid
erDiagram
    users ||--o{ triggers : "manages"
    triggers }o--|| templates : "uses"
    users ||--o{ activity_log : "performs"
    
    users {
        uuid id
        string email
        timestamp created_at
    }
    
    triggers {
        uuid id
        uuid user_id
        uuid template_id
        string post_id
        string keyword
        boolean is_active
        timestamp created_at
    }
    
    templates {
        uuid id
        string content
        string media_url
        json metadata
        timestamp created_at
    }
    
    activity_log {
        uuid id
        uuid user_id
        string action
        json details
        timestamp created_at
    }
```

## Table Details

### `users` (Supabase Auth)
- Extends default Supabase auth.users table
- Stores admin panel users
- **Relationships**:
  - Has many `triggers`
  - Has many `activity_log` entries

### `triggers`
- Stores Instagram post/keyword configurations
- **Fields**:
  - `post_id`: Instagram post ID to monitor
  - `keyword`: Trigger word/phrase
  - `is_active`: Enable/disable toggle
- **Indexes**:
  - `idx_triggers_post_id` (post_id)
  - `idx_triggers_keyword` (keyword)

### `templates`
- Stores DM response content
- **Fields**:
  - `content`: Message text (supports variables)
  - `media_url`: Optional image/video URL
  - `metadata`: Additional config (e.g., buttons)
  
### `activity_log`
- Tracks system events
- **Fields**:
  - `action`: Event type (e.g., "dm_sent")
  - `details`: JSON payload with context

## Sample Queries

1. Get active triggers for a post:
```sql
SELECT * FROM triggers 
WHERE post_id = 'INSTAGRAM_POST_ID' 
AND is_active = true;
```

2. Get template for a keyword:
```sql
SELECT t.* FROM templates t
JOIN triggers tr ON tr.template_id = t.id
WHERE tr.keyword = 'WIN'
LIMIT 1;
```

3. Recent admin activity:
```sql
SELECT * FROM activity_log
WHERE user_id = 'ADMIN_UUID'
ORDER BY created_at DESC
LIMIT 10;
</file>

<file path="documentation/functional_requirements.md">
# Functional Requirements

## Instagram Bot Functionality

### Comment Monitoring
- Continuously polls Instagram API for new comments
- Filters comments based on:
  - Post ID (configured triggers only)
  - Keyword matches (exact and partial matches)
  - User eligibility (exclude blocked users)

### Keyword Matching
- Supports:
  - Exact match triggers (e.g., "WIN")
  - Partial match triggers (e.g., "promo*")
  - Case-insensitive matching
- Priority system for multiple matches

### DM Response System
- Selects appropriate template based on:
  - Matched keyword
  - User history (avoid duplicates)
- Sends DM containing:
  - Preconfigured text
  - Optional media attachment
  - Tracking pixel for analytics
- Rate limiting: Max 1 DM per user per hour

## Admin Panel Features

### Authentication
- Supabase email/password login
- Session management (30min timeout)
- Role-based access (Admin/Viewer)

### Trigger Management
- CRUD operations for:
  - Post IDs to monitor
  - Trigger keywords
  - Response templates
- Activation toggle per trigger
- Bulk import/export via CSV

### Template Management
- Create/edit DM templates with:
  - Text content (markdown supported)
  - Media attachments (images/videos)
  - Tracking parameters
- Preview functionality
- Version history

### Dashboard
- Real-time metrics:
  - Total triggers activated
  - DMs sent (success/failure)
  - Popular keywords
- System health monitoring

## System Constraints
- Instagram API rate limits:
  - Max 200 comments/min
  - Max 30 DMs/min
- Local storage limits:
  - 1GB media cache
  - 7d activity logs
- Performance targets:
  - <2s response time for admin panel
  - <5s DM delivery after comment

## Error Handling
- Failed DM retries (3 attempts)
- Invalid comment skipping
- API outage recovery:
  - 15min backoff period
  - Local queue for pending DMs
- Admin alerts for:
  - Continuous failures
  - Storage limits
  - Auth breaches
</file>

<file path="documentation/master_plan.md">
# Master Documentation Plan

Based on the vision in [`app_description.md`](app_description.md), create the following documents:

- [x] **1. Business Requirements Document** (`documentation/business_requirements.md`)
  - Project overview and objectives
  - Stakeholder analysis
  - User stories for:
    - Instagram users receiving DMs
    - Admin users managing triggers
  - Success metrics

- [x] **2. Functional Requirements** (`documentation/functional_requirements.md`)
  - Instagram bot functionality:
    - Comment monitoring workflow
    - Keyword matching logic
    - DM sending process
  - Admin panel features:
    - Authentication flow
    - CRUD operations for triggers
    - DM template management
  - System constraints and edge cases

- [x] **3. Technical Design Specification** (`documentation/technical_design.md`)
  - System architecture diagram
  - Component breakdown:
    - Instagram bot service
    - Admin panel (Next.js)
    - Database layer
  - API specifications:
    - Internal bot-admin communication
    - Supabase integration points
  - Security considerations

- [x] **4. Database Schema** (`documentation/database_schema.md`)
  - Supabase tables:
    - `users` (Supabase Auth)
    - `triggers` (keyword configurations)
    - `dm_templates` (response content)
    - `activity_log` (bot operations)
  - Relationships and indexes
  - Sample queries

- [x] **5. API Documentation** (`documentation/api_spec.md`)
  - Admin panel API routes:
    - /api/triggers (CRUD)
    - /api/templates (CRUD)
  - Bot healthcheck endpoints
  - Authentication requirements
  - Request/response examples

- [x] **6. Deployment Guide** (`documentation/deployment_guide.md`)
  - Docker compose configuration
  - Environment variables
  - Initial setup steps
  - Local development workflow
  - Testing procedures
</file>

<file path="documentation/technical_design.md">
# Technical Design Specification

## System Architecture
```text
[Instagram Users] <-> [Instagram API] <-> [Python Bot Service]
                             ^
                             |
                             v
[Admin Users] <-> [Next.js Admin Panel] <-> [Supabase Database]
```

### Components
1. **Instagram Bot Service** (Python)
   - Comment polling every 60s
   - Keyword matching engine
   - DM sending queue
   - Error handling and retries

2. **Admin Panel** (Next.js 14)
   - App Router structure:
     - `/app/login` - Auth page
     - `/app/dashboard` - Main interface
     - `/app/triggers` - CRUD operations
   - API Routes:
     - `/api/triggers` - Manage keywords
     - `/api/templates` - Handle DM content

3. **Database** (Supabase)
   - Tables:
     - `triggers` (post_id, keyword, template_id, is_active)
     - `templates` (content, media_url, metadata)
     - `activity_log` (timestamp, user_id, action)

## API Specifications

### Bot Service API
- POST `/bot/healthcheck` - Monitoring endpoint
- GET `/bot/config` - Retrieve active triggers

### Admin Panel API
- CRUD endpoints for all database tables
- JWT authentication via Supabase

### Supabase Integration
- Auth: Email/password with sessions
- Storage: Media files for DM templates
- Realtime: Updates to trigger configurations

## Security Design
- Rate limiting on public endpoints
- JWT validation for admin API
- Encrypted database connections
- Regular security audits

## Infrastructure
- Docker Compose setup:
  - `admin-panel` service (Next.js)
  - `bot-service` service (Python)
  - `supabase` service (local emulator)
- Environment variables for configuration
- Health monitoring endpoints

## Performance Considerations
- Caching of frequent API calls
- Bulk operations for trigger updates
- Async processing for DM delivery
</file>

<file path="instagram_bot/tests/mock_services.py">
from unittest.mock import Mock

class MockInstagramAPI:
    def __init__(self):
        self.check_comments = Mock(return_value=[])
        self.login = Mock()
        self.send_dm = Mock()

    def set_comments(self, comments):
        self.check_comments.return_value = comments

class MockDatabase:
    def __init__(self):
        self.cursor = Mock()
        self.cursor().execute = Mock()
        self.cursor().fetchall = Mock(return_value=[])
        self.commit = Mock()

    def set_query_results(self, results):
        self.cursor().fetchall.return_value = results
</file>

<file path="instagram_bot/tests/test_config.py">
# Test configuration with dummy credentials
INSTAGRAM_USER = "test_user"
INSTAGRAM_PASSWORD = "test_password"
</file>

<file path="instagram_bot/.env.example">
# Instagram credentials
INSTAGRAM_USER=your_instagram_username
INSTAGRAM_PASSWORD=your_instagram_password

# Database credentials
DB_HOST=db
DB_PORT=5432
DB_NAME=postgres
DB_USER=postgres
DB_PASSWORD=password
</file>

<file path="instagram_bot/Dockerfile">
# Use the official Python image from the Docker Hub
FROM python:3.10-slim

# Set the working directory
WORKDIR /app

# Copy the requirements file
COPY requirements.txt .

# Install the dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of the application code
COPY . .

# Set environment variables from .env file
ENV ENV_FILE=.env
RUN if [ -f $ENV_FILE ]; then export $(cat $ENV_FILE | grep -v ^# | xargs); fi

# Command to run the application
CMD ["python", "main.py"]
</file>

<file path="instagram_bot/instagram_bot.py">
#!/usr/bin/env python3

import os
import time
import logging
import psycopg2
from dotenv import load_dotenv
from instagrapi import Client
from instagrapi.types import StoryMedia, StorySticker, StoryMention, StoryHashtag, StoryLocation

# Load environment variables
load_dotenv()

# Set up logging
logger = logging.getLogger(__name__)

class InstagramBot:
    def __init__(self):
        """Initialize the Instagram bot."""
        self.instagram_user = os.getenv("INSTAGRAM_USER")
        self.instagram_password = os.getenv("INSTAGRAM_PASSWORD")
        self.db_host = os.getenv("DB_HOST", "localhost")
        self.db_port = os.getenv("DB_PORT", "5432")
        self.db_name = os.getenv("DB_NAME", "postgres")
        self.db_user = os.getenv("DB_USER", "postgres")
        self.db_password = os.getenv("DB_PASSWORD", "password")

        # Initialize Instagram client
        self.client = None

        # Initialize database connection
        self.db_conn = None
        self.db_cursor = None

        logger.info("InstagramBot initialized")

    def connect_to_instagram(self):
        """Connect to Instagram API."""
        logger.info("Connecting to Instagram...")
        self.client = Client()
        self.client.login(self.instagram_user, self.instagram_password)
        logger.info("Successfully connected to Instagram")

    def connect_to_database(self):
        """Connect to the PostgreSQL database."""
        logger.info("Connecting to database...")
        self.db_conn = psycopg2.connect(
            host=self.db_host,
            port=self.db_port,
            dbname=self.db_name,
            user=self.db_user,
            password=self.db_password
        )
        self.db_cursor = self.db_conn.cursor()
        logger.info("Successfully connected to database")

    def fetch_triggers(self):
        """Fetch active triggers from the database."""
        logger.info("Fetching active triggers from database...")
        self.db_cursor.execute("SELECT id, post_id, keyword, template_id FROM triggers WHERE is_active = TRUE")
        triggers = self.db_cursor.fetchall()
        logger.info(f"Fetched {len(triggers)} active triggers")
        return triggers

    def fetch_templates(self):
        """Fetch DM templates from the database."""
        logger.info("Fetching DM templates from database...")
        self.db_cursor.execute("SELECT id, content, media_url FROM dm_templates")
        templates = self.db_cursor.fetchall()
        logger.info(f"Fetched {len(templates)} DM templates")
        return templates

    def check_comments(self, post_id, keywords):
        """Check for new comments on a post and match keywords."""
        logger.info(f"Checking comments for post {post_id} with keywords {keywords}")
        post = self.client.post_info(post_id)
        new_comments = []

        for comment in post.comments:
            for keyword in keywords:
                if keyword.lower() in comment.text.lower():
                    new_comments.append(comment)
                    logger.info(f"Matched keyword '{keyword}' in comment: {comment.text}")

        return new_comments

    def send_dm(self, user_id, template):
        """Send a direct message to a user."""
        logger.info(f"Sending DM to user {user_id} with template: {template}")
        self.client.direct_message(user_id, template['content'])

        # Log the activity
        self.log_activity(user_id, template['content'])

    def log_activity(self, user_id, message):
        """Log bot activity to the database."""
        logger.info(f"Logging activity for user {user_id}")
        self.db_cursor.execute(
            "INSERT INTO activity_log (user_id, action, details) VALUES (%s, %s, %s)",
            (user_id, "sent_dm", message)
        )
        self.db_conn.commit()

    def run(self):
        """Main bot loop."""
        # Connect to services
        self.connect_to_instagram()
        self.connect_to_database()

        # Fetch configuration
        triggers = self.fetch_triggers()
        # Build templates dictionary with ID as key
        templates_dict = {
            str(t[0]): {  # Ensure key is string to match database UUID string format
                'content': t[1],
                'media_url': t[2]
            } for t in templates
        }
        logger.info(f"Loaded {len(templates_dict)} templates into memory")

        # Main loop
        while True:
            for trigger in triggers:
                post_id = trigger[1]
                keyword = trigger[2]

                # Check for new comments
                matched_comments = self.check_comments(post_id, [keyword])

                # Send DMs for matched comments
                for comment in matched_comments:
                    user_id = comment.user.id
                    template_id = trigger[3]  # template_id is the 4th element

                    if not template_id:
                        logger.error(f"Trigger {trigger[0]} has no template_id assigned")
                        continue
                        
                    template = templates_dict.get(str(template_id))
                    if template:
                        self.send_dm(user_id, template)
                    else:
                        logger.error(f"No template found with ID {template_id} for trigger {trigger[0]}")
                        # TODO: Consider implementing dead-letter queue or alerting

            # Wait before next check
            time.sleep(60)  # Check every minute

    def __del__(self):
        """Clean up resources."""
        if self.db_conn:
            self.db_conn.close()
            logger.info("Closed database connection")
</file>

<file path="instagram_bot/main.py">
#!/usr/bin/env python3

import os
import logging
from dotenv import load_dotenv
from instagram_bot import InstagramBot

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("bot.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def main():
    """Main function to run the Instagram bot."""
    logger.info("Starting Instagram bot service...")

    # Initialize the bot
    bot = InstagramBot()

    # Start the bot
    bot.run()

if __name__ == "__main__":
    main()
</file>

<file path="supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path="app_description.md">
# Instagram Comment-to-DM Bot System

## Project Vision
Create an automated system where:
1. Users commenting with specific keywords on Instagram posts receive automated DMs
2. Admins can manage triggers and DM content through a web panel
3. Entire system runs locally via Docker for easy testing

## Core Components
### Instagram Bot
- Python-based service monitoring Instagram comments
- Matches comments against admin-defined keywords
- Sends pre-configured DM responses (text/media) to matching users
- Runs in background 24/7

### Admin Panel
- Next.js 14 application with App Router
- Authentication via Supabase Auth
- CRUD operations for:
  - Instagram post triggers (keywords)
  - DM response templates (text/media)
  - Activation status
- Dashboard showing trigger statistics
- Tailwind CSS for styling

### Database & Storage
- Supabase PostgreSQL for:
  - User accounts (Supabase Auth)
  - Trigger configurations
  - DM templates
- Supabase Storage for media files in DMs

## Tech Stack
### Backend Services
- Instagram Bot: Python + Instagram API wrapper
- Admin API: Next.js API routes

### Frontend
- Next.js 14
- Tailwind CSS
- Prisma ORM

### Infrastructure
- Docker Compose for local development
- Supabase for:
  - Authentication
  - Database
  - File storage

## Key Requirements
1. Single-command startup: `docker-compose up`
2. Isolated services:
   - Admin panel (Next.js)
   - Instagram bot (Python)
   - Database (Supabase local)
3. Secure admin authentication
4. Configurable triggers/DM content
</file>

<file path="dev_todo_item-01.md">
# Development Plan for Ticket 1: Implement Core Instagram Bot Service

## Objective
Implement a Python-based Instagram bot service that monitors comments, matches keywords, and sends automated DMs.

## Steps

1. **Create Python application structure**
   - Create `/bot` directory with required files:
     - `Dockerfile` (for containerization)
     - `requirements.txt` (dependencies)
     - `main.py` (entry point)
     - `instagram_bot.py` (core functionality)
     - `.env.example` (environment variables)

## Dependencies
- Python 3.10+
- Libraries: instagrapi, python-dotenv, psycopg2 (PostgreSQL), requests

## Notes
- Use environment variables for all credentials
- Follow Instagram API best practices to avoid bans
- Implement proper backoff strategies for rate limits
- All database operations should use parameterized queries
</file>

<file path="dev_todo_phase_2.md">
# Phase 2: Admin Panel Enhancements

## Ticket 2: Fix Critical Data-Fetching Bugs in Analytics Dashboard
- [x] **(LOGIC)** Modify `getDashboardAnalytics` function in [`admin/admin/src/lib/actions.ts`](admin/admin/src/lib/actions.ts)
- [x] **(LOGIC)** Correct user activity query to use existing fields
- [x] **(LOGIC)** Update template usage query to use `content` field instead of non-existent `name` field
- [x] **(UI)** Verify dashboard page loads without crashing

## Ticket 3: Implement Missing REST APIs for Triggers and Templates
- [ ] **(LOGIC)** Create API route for triggers: [`admin/admin/src/app/api/triggers/[[...slug]]/route.ts`](admin/admin/src/app/api/triggers/[[...slug]]/route.ts)
- [ ] **(LOGIC)** Create API route for templates: [`admin/admin/src/app/api/templates/[[...slug]]/route.ts`](admin/admin/src/app/api/templates/[[...slug]]/route.ts)
- [ ] **(LOGIC)** Implement full CRUD operations for triggers
- [ ] **(LOGIC)** Implement full CRUD operations for templates
- [ ] **(LOGIC)** Add authentication to all API endpoints

## Ticket 4: Create Template Management User Interface
- [ ] **(UI)** Create template management page: [`admin/admin/src/app/dashboard/templates/page.tsx`](admin/admin/src/app/dashboard/templates/page.tsx)
- [ ] **(UI)** Implement data table to display templates
- [ ] **(UI)** Create form for creating/editing templates
- [ ] **(UI)** Connect form to existing server actions
- [ ] **(UI)** Add navigation link to templates page in sidebar

## Ticket 6: Implement Authentication Guard for Dashboard Routes
- [ ] **(LOGIC)** Create authentication check in [`admin/admin/src/app/dashboard/layout.tsx`](admin/admin/src/app/dashboard/layout.tsx)
- [ ] **(LOGIC)** Verify user session with Supabase client
- [ ] **(LOGIC)** Implement redirect to login page for unauthenticated users
- [ ] **(UI)** Test that dashboard routes are protected
</file>

<file path="master_development_plan.md">
# Master Development Plan

## Phase 1: Core Bot Service Implementation
- [x] Implement Core Instagram Bot Service (Ticket #1)

## Phase 2: Admin Panel Enhancements
- [ ] Fix Critical Data-Fetching Bugs (Ticket #2)
- [ ] Implement Missing REST APIs (Ticket #3)
- [ ] Create Template Management UI (Ticket #4)
- [ ] Implement Authentication Guard (Ticket #6)

## Phase 3: Documentation Update
- [ ] Correct and Align All Project Documentation (Ticket #5)

## Phase 4: Final Testing
- [ ] Complete final testing of all implemented features
</file>

<file path="setup.py">
from setuptools import setup, find_packages

setup(
    name="instagram_bot",
    version="0.1",
    packages=find_packages(),
    install_requires=[
        "instagrapi",
        "python-dotenv",
        "psycopg2-binary",
        "requests",
        "pillow>=8.1.1"
    ],
)
</file>

<file path="vercel.json">
{
  "build": {
    "env": {
      "NEXT_PUBLIC_SUPABASE_URL": "@supabase-url",
      "NEXT_PUBLIC_SUPABASE_ANON_KEY": "@supabase-anon-key"
    }
  },
  "routes": [
    {
      "src": "/.*",
      "dest": "/"
    }
  ],
  "version": 2,
  "buildCommand": "npm run build",
  "outputDirectory": ".next"
}
</file>

<file path=".github/workflows/main.yml">
name: CI/CD Pipeline

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v3

    - name: Use Node.js 18.x
      uses: actions/setup-node@v3
      with:
        node-version: 18.x
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run database migrations
      run: npx prisma migrate dev --name ci-setup --schema=./admin/admin/prisma/schema.prisma
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test

    - name: Generate Prisma client
      run: npx prisma generate --schema=./admin/admin/prisma/schema.prisma

    - name: Run linting
      run: npm run lint

    - name: Run tests
      run: npm test

    - name: Build project
      run: npm run build

  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v3

    - name: Use Node.js 18.x
      uses: actions/setup-node@v3
      with:
        node-version: 18.x

    - name: Install dependencies
      run: npm ci

    - name: Build project
      run: npm run build
      env:
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}

    - name: Deploy to Vercel
      uses: amondnet/vercel-action@v25
      with:
        vercel-token: ${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
        vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
        scope: ${{ secrets.VERCEL_ORG_ID }}
</file>

<file path="admin/admin/src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { SupabaseProvider } from "@/lib/supabase-provider";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <SupabaseProvider>
          {children}
        </SupabaseProvider>
      </body>
    </html>
  );
}
</file>

<file path="admin/admin/src/components/ui/bar-chart.tsx">
'use client'

import { Bar } from 'react-chartjs-2'
import { 
  Chart as ChartJS, 
  CategoryScale, 
  LinearScale, 
  BarElement, 
  Title, 
  Tooltip, 
  Legend 
} from 'chart.js'

ChartJS.register(
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend
)

type BarChartDataItem = Record<string, unknown> // Generic chart data type

interface BarChartProps {
  datasets: BarChartDataItem[]
  xAxis: string
  yFields: string[]
  title?: string
  colors?: string[]
}

export function BarChart({ datasets, xAxis, yFields, title, colors }: BarChartProps) {
  const chartData = {
    labels: datasets.map(item => item[xAxis]),
    datasets: yFields.map((field, index) => ({
      label: field,
      data: datasets.map(item => item[field]),
      backgroundColor: colors?.[index] || 'rgba(59, 130, 246, 0.5)'
    }))
  }

  const options = {
    responsive: true,
    plugins: {
      legend: {
        position: 'top' as const,
      },
      title: {
        display: !!title,
        text: title,
      },
      tooltip: {
        mode: 'index' as const,
        intersect: false,
      },
    },
    interaction: {
      mode: 'index' as const,
      intersect: false,
    },
  }

  return <Bar options={options} data={chartData} />
}
</file>

<file path="admin/admin/src/components/bot-health-status.tsx">
import type { BotHealthStatus } from '@/bot-monitor/types'

export function BotHealthStatusCard({ status }: { status: BotHealthStatus }) {
  return (
    <div className="p-4 border rounded-lg">
      <h3 className="text-lg font-semibold mb-2">Bot Health Status</h3>
      <div className="space-y-1">
        <p>Last ping: {status.lastPing.toLocaleString()}</p>
        <p>Status: {status.isHealthy ?
          <span className="text-green-500">Healthy</span> :
          <span className="text-red-500">Unhealthy</span>}
        </p>
        <p>Error count: {status.errorCount}</p>
        {status.storageUsage !== undefined && (
          <p>Storage usage: {status.storageUsage.toFixed(2)} MB</p>
        )}
        {status.authBreaches !== undefined && (
          <p>Auth breaches: {status.authBreaches}</p>
        )}
      </div>
    </div>
  )
}
</file>

<file path="admin/admin/src/lib/supabase.ts">
import { createBrowserClient } from '@supabase/ssr'
import { Database } from '@/types/database'

export function createClient() {
  return createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_KEY!
  )
}
</file>

<file path="admin/admin/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

/src/generated/prisma
</file>

<file path="bot/__init__.py">
# Bot service initialization
</file>

<file path="bot/main.py">
#!/usr/bin/env python3
"""
Instagram Bot Service Main Entry Point
"""

import os
import sys
import logging
import time
from instagram_bot import InstagramBot

def setup_logging():
    """Set up logging configuration"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler("logs/system_events.log"),
            logging.StreamHandler(sys.stdout)
        ]
    )

def main():
    """Main function to run the Instagram bot service"""
    setup_logging()
    logger = logging.getLogger(__name__)

    logger.info("Starting Instagram Bot Service")

    # Initialize the bot
    bot = InstagramBot()

    # Run the bot in a loop
    try:
        while True:
            bot.run()
            time.sleep(60)  # Run every minute
    except KeyboardInterrupt:
        logger.info("Bot service stopped by user")
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
</file>

<file path="documentation/deployment_guide.md">
# Deployment Guide

## System Requirements
- Python 3.8+
- PostgreSQL 12+
- Node.js 16+ (for admin interface)

## Installation
1. Clone the repository:
   ```bash
   git clone https://github.com/your-org/arina_admin_instagram.git
   cd arina_admin_instagram
   ```

2. Set up Python environment:
   ```bash
   python3 -m venv .venv
   source .venv/bin/activate
   pip install -r instagram_bot/requirements.txt
   ```

3. Set up environment variables:
   ```bash
   cp instagram_bot/.env.example instagram_bot/.env
   # Edit the .env file with your credentials
   ```

4. Set up database:
   ```bash
   # Create and migrate database using Supabase CLI
   cd supabase
   supabase start
   ```

## Running the Application
1. Start the Instagram bot:
   ```bash
   cd instagram_bot
   python main.py
   ```

2. Start the admin interface:
   ```bash
   cd admin/admin
   npm install
   npm run dev
   ```

## Testing
### Python Environment Setup
1. Create virtual environment:
   ```bash
   python3 -m venv .venv
   source .venv/bin/activate
   ```
2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

### Running Tests
Execute tests with mocks:
```bash
pytest instagram_bot/tests --disable-pytest-warnings
```

### Test Configuration
The test configuration is located in `instagram_bot/tests/test_config.py`. This file contains mock credentials and settings for testing.
</file>

<file path="instagram_bot/__init__.py">
# Package initialization file
</file>

<file path="instagram_bot/requirements.txt">
instagrapi
python-dotenv
psycopg2-binary
requests
Pillow>=8.1.1
</file>

<file path="instagram_bot/test_instagram_bot.py">
import unittest
import logging
from unittest.mock import Mock
from instagram_bot.instagram_bot import InstagramBot, logger as bot_logger
from .tests.mock_services import MockDatabase, MockInstagramAPI

class TestInstagramBot(unittest.TestCase):
    def setUp(self):
        self.bot = InstagramBot()
        # Replace real services with mocks
        self.bot.db_conn = MockDatabase()
        self.bot.client = MockInstagramAPI()
        # Mock other dependencies
        self.bot.fetch_triggers = Mock()
        self.bot.fetch_templates = Mock()
        self.bot.log_activity = Mock()
        self.bot.run = Mock(wraps=self.bot.run)
        
        # Set dummy credentials to avoid login errors
        self.bot.instagram_user = "test_user"
        self.bot.instagram_password = "test_pass"

    def test_fetch_triggers_includes_template_id(self):
        # Setup mock database response
        expected_triggers = [
            ('trigger1', 'post1', 'keyword1', 'template1'),
            ('trigger2', 'post2', 'keyword2', 'template2')
        ]
        self.bot.db_conn.cursor().fetchall.return_value = expected_triggers
        
        # Fetch triggers
        triggers = self.bot.fetch_triggers()
        
        # Verify the SQL query includes template_id
        self.bot.db_conn.cursor().execute.assert_called_once_with(
            "SELECT id, post_id, keyword, template_id FROM triggers WHERE is_active = TRUE"
        )
        
        # Verify the returned triggers include template_id
        self.assertEqual(triggers, expected_triggers)

    def test_run_with_trigger_missing_template_id(self):
        """Test run loop when trigger has no template_id assigned"""
        # Setup
        self.bot.fetch_triggers.return_value = [
            ('trigger1', 'post1', 'keyword1', None),  # No template_id
            ('trigger2', 'post2', 'keyword2', 'template2')
        ]
        self.bot.fetch_templates.return_value = [('template2', 'Content', None)]
        
        # Simulate finding a comment
        self.bot.client.check_comments.return_value = [Mock(user=Mock(id='user1'))]
        
        # Run one iteration
        with self.assertLogs(bot_logger, level='ERROR') as log:
            self.bot.run()
        
        # Verify error was logged for trigger1
        self.assertIn("has no template_id assigned", log.output[0])
        # Verify DM was only sent for trigger2
        self.bot.send_dm.assert_called_once_with('user1', {'content': 'Content', 'media_url': None})

    def test_run_with_template_not_found(self):
        """Test run loop when template_id not found in templates_dict"""
        # Setup
        self.bot.fetch_triggers.return_value = [
            ('trigger1', 'post1', 'keyword1', 'missing_template'),
        ]
        self.bot.fetch_templates.return_value = [('template2', 'Content', None)]
        
        # Simulate finding a comment
        self.bot.client.check_comments.return_value = [Mock(user=Mock(id='user1'))]
        
        # Run one iteration
        with self.assertLogs(bot_logger, level='ERROR') as log:
            self.bot.run()
        
        # Verify error was logged
        self.assertIn("No template found with ID", log.output[0])
        # Verify no DM was sent
        self.bot.send_dm.assert_not_called()

if __name__ == '__main__':
    unittest.main()
</file>

<file path="supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "arina_admin_instagram"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 1

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path="work_items/ticket-01-implement-bot-service.md">
# Ticket 1: Implement Core Instagram Bot Service

**State:** COMPLETED
**Priority:** CRITICAL  
**Effort:** XL  
**Component:** `bot-service`

### Description

The primary functional component of the system, the Python-based Instagram bot, is completely missing from the codebase. The `docker-compose.yml` file defines a `bot-service` that points to an empty `/bot` directory.

### Acceptance Criteria

1.  Create a new Python application within the `/bot` directory.
2.  The application must be ableto be built and run by the existing `docker-compose.yml` configuration.
3.  Implement functionality to connect to the Supabase database to fetch active triggers and templates.
4.  Implement a polling mechanism to monitor comments on specified Instagram posts.
5.  Implement keyword matching logic based on the fetched triggers.
6.  Implement DM sending functionality using the appropriate template for a matched keyword.
7.  Ensure the service logs its activity to the `activity_log` table as defined in the project's documentation.
8.  Reference `documentation/technical_design.md` for the high-level architecture.
</create_file>
<create_file path="work_items/ticket-02-fix-dashboard-bugs.md">
# Ticket 2: Fix Critical Data-Fetching Bugs in Analytics Dashboard

**State:** OPEN  
**Priority:** CRITICAL  
**Effort:** M  
**Component:** `admin-panel`

### Description

The Analytics Dashboard at `/dashboard` is non-functional and will cause a server crash due to fatal errors in its data-fetching logic. The `getDashboardAnalytics` server action in `admin/admin/src/lib/actions.ts` attempts to query fields that do not exist in the Prisma schema.

### Bug Details

-   **File:** `admin/admin/src/lib/actions.ts`
-   **Function:** `getDashboardAnalytics`
-   **Invalid Query 1:** The query on the `User` model filters by a `lastLogin` field, which does not exist. The `User` model in `prisma/schema.prisma` has no such field.
-   **Invalid Query 2:** The query on the `Template` model selects a `name` field, which does not exist. The `Template` model has a `content` field but no `name`.

### Acceptance Criteria

1.  Modify the `getDashboardAnalytics` function in `admin/admin/src/lib/actions.ts`.
2.  Correct the user activity query. A different metric for "active users" must be devised (e.g., based on recent entries in `activity_log`) or the metric must be removed.
3.  Correct the template usage query to use an existing, relevant field from the `Template` model, such as `content` or `id`, for identifying templates.
4.  The dashboard page at `/dashboard` must load without crashing and display the analytics charts with the corrected data.
</create_file>
<create_file path="work_items/ticket-03-implement-rest-apis.md">
# Ticket 3: Implement Missing REST APIs for Triggers and Templates

**State:** OPEN  
**Priority:** HIGH  
**Effort:** L  
**Component:** `admin-panel`

### Description

The backend is missing the REST API endpoints required for managing triggers and templates, despite them being defined in the project's technical documentation. The only existing APIs are for bot health.

### Acceptance Criteria

1.  Create the necessary Next.js API route files to handle trigger and template management.
    -   Suggested location: `admin/admin/src/app/api/triggers/[[...slug]]/route.ts`
    -   Suggested location: `admin/admin/src/app/api/templates/[[...slug]]/route.ts`
2.  Implement full CRUD (Create, Read, Update, Delete) functionality for both `triggers` and `templates`.
3.  The API logic should use the Prisma client to interact with the database.
4.  Secure all endpoints, requiring valid user authentication for any operation.
5.  Ensure the implementation matches the specifications laid out in `documentation/api_spec.md`.
</create_file>
<create_file path="work_items/ticket-04-create-template-ui.md">
# Ticket 4: Create Template Management User Interface

**State:** OPEN  
**Priority:** HIGH  
**Effort:** M  
**Component:** `admin-panel`

### Description

The admin panel lacks the user interface for managing DM templates. While the backend models and actions exist, there is no corresponding page for admins to perform CRUD operations. The original plan in `todos/dev_todo_phase_3.md` was not completed.

### Acceptance Criteria

1.  Create a new page at `admin/admin/src/app/dashboard/templates/page.tsx`.
2.  This page should display a list of all existing templates in a data table, showing template content and status.
3.  Include a "Create New Template" button on the page.
4.  Implement a form (either on a new page or in a modal) for creating and editing templates. The form should include fields for `content`, `mediaUrl`, and an `isActive` toggle.
5.  Connect the form to the existing `createTemplate` and `updateTemplate` server actions.
6.  Ensure "Edit" and "Delete" buttons are present for each template in the list and are connected to the appropriate server actions.
7.  Add a navigation link to `/dashboard/templates` in the main sidebar.
</create_file>
<create_file path="work_items/ticket-05-update-documentation.md">
# Ticket 5: Correct and Align All Project Documentation

**State:** OPEN  
**Priority:** MEDIUM  
**Effort:** L  
**Component:** `documentation`

### Description

The project documentation in the `/documentation` directory is severely outdated and does not accurately represent the codebase. It describes features that don't exist and configurations that are incorrect. This ticket should be completed *after* all other implementation and bug-fix tickets are resolved.

### Inaccurate Documents

-   `documentation/api_spec.md`: Describes APIs that were never built.
-   `documentation/technical_design.md`: Describes a Python bot that is missing.
-   `documentation/deployment_guide.md`: Contains an incorrect `docker-compose.yml` example with wrong ports and service definitions.
-   Other documents may contain similar inaccuracies.

### Acceptance Criteria

1.  Thoroughly review every file in the `/documentation` directory.
2.  Update the `technical_design.md` and related documents to reflect the *actual* implementation of the bot service (once Ticket #1 is complete).
3.  Update `api_spec.md` to match the *actual* implemented REST APIs (once Ticket #3 is complete).
4.  Correct the `docker-compose.yml` example in `deployment_guide.md` to match the root `docker-compose.yml` file.
5.  Ensure all user stories and requirements from the business/functional documents are met by the final codebase and that the documentation reflects this.
</create_file>
<create_file path="work_items/ticket-06-implement-auth-guard.md">
# Ticket 6: Implement Authentication Guard for Dashboard Routes

**State:** OPEN  
**Priority:** HIGH  
**Effort:** S  
**Component:** `admin-panel`

### Description

The application currently lacks a mechanism to protect the dashboard routes from unauthenticated access. A user can navigate directly to `/dashboard` without being logged in.

### Acceptance Criteria

1.  Implement an authentication check that runs for all routes under `/dashboard`.
2.  A layout file at `admin/admin/src/app/dashboard/layout.tsx` is the preferred location for this logic.
3.  The check should use the Supabase client to verify if a valid user session exists.
4.  If no session is found, the user must be redirected to the `/login` page.
5.  The implementation should be server-side to prevent the dashboard UI from ever rendering for an unauthenticated user.
</create_file>
</file>

<file path="README.md">
# Instagram Comment-to-DM Bot System

Automatically send DMs to users who comment with specific keywords on Instagram posts. Includes an admin panel for managing triggers and responses.

## Features
- Instagram bot service (Python)
- Admin web panel (Next.js)
- Supabase backend (Auth, Database, Storage)
- Dockerized development environment

## Prerequisites
- Docker and Docker Compose
- Instagram API credentials
- Supabase account

## Getting Started

1. **Clone the repository**
   ```bash
   git clone https://github.com/yourusername/arina_admin_instagram.git
   cd arina_admin_instagram
   ```

2. **Set up environment variables**
   - Copy `.env.example` to `.env` in both `admin/admin` and bot directories
   - Fill in your credentials:
     - Instagram API keys
     - Supabase URL and anon key
     - Admin panel secret keys

3. **Start the system**
   ```bash
   docker-compose up --build
   ```

4. **Access the services**
   - Admin panel: http://localhost:3111
   - Bot logs: `docker-compose logs bot`

## Configuration

### Admin Panel
1. Visit http://localhost:3111/login
2. Create your admin account
3. Configure:
   - Instagram posts to monitor
   - Trigger keywords
   - DM response templates

### Instagram Bot
1. Ensure your Instagram account is properly authenticated
2. The bot will automatically:
   - Monitor specified posts
   - Detect trigger keywords
   - Send configured DM responses

## Troubleshooting

**Common Issues:**
- Instagram API limits: Ensure proper rate limiting
- Database connection: Verify Supabase credentials
- Docker issues: Check container logs with `docker-compose logs`

For full documentation, see the `/documentation` directory.
</file>

<file path=".roo/rules-qa-engineer/rules.md">
## 1. IDENTITY & PERSONA
You are the **Auditor AI** (ðŸ”Ž The Auditor). You are the ultimate gatekeeper of quality. Your sole purpose is to verify that the final codebase is a 100% perfect implementation of the `canonical_spec.md`.

## 2. THE CORE MISSION & TRIGGER
Your mission is to perform a holistic audit of the entire project. You are triggered by the Orchestrator when the `/signals/IMPLEMENTATION_COMPLETE.md` signal exists.

## 3. THE HOLISTIC AUDIT WORKFLOW
1.  **Acknowledge & Log:** "Implementation is complete. Beginning full system audit against the canonical specification."
2.  **Consume Signal:** Delete `/signals/IMPLEMENTATION_COMPLETE.md`.
3.  **Perform Verification:**
    *   Read `/docs/canonical_spec.md`. This is your only source of truth.
    *   Analyze the entire codebase. Use `<codebase_search>` extensively to map features to code.
    *   Run any and all tests that exist.
4.  **Decision & Action:**
    *   **If the codebase perfectly matches 100% of the spec:**
        *   Create the signal file `/signals/PROJECT_AUDIT_PASSED.md`.
        *   Announce: "Project has passed the full audit and meets 100% of the specification. The project is complete."
        *   Handoff to `<mode>orchestrator</mode>`.
    *   **If there are ANY gaps, bugs, or deviations:**
        *   Create a new work item file in `/work_items/` (e.g., `item-001-missing-password-reset.md`).
        *   The file must contain a detailed description of the gap between the spec and the implementation.
        *   Announce: "Audit failed. A new work item has been created to address the gap. Restarting the planning loop."
        *   Handoff to `<mode>orchestrator</mode>`.
</file>

<file path=".roo/custom_modes.yaml">
---
customModes:
  - slug: product-manager
    name: Product Manager (The Clarifier)
    roleDefinition: >-
      You are the **Product Manager AI** (ðŸ“ˆ). Your sole purpose is to transform the user's initial, potentially vague `app_description.md` into a comprehensive and unambiguous `/docs/canonical_spec.md`. You are the source of project truth.
    groups: [read, edit, command, mcp]
    source: global

  - slug: architect
    name: Architect (The Master Planner)
    roleDefinition: >-
      You are the **Architect AI** (ðŸ§ ). Triggered by a complete specification, you perform a single, upfront planning session to create a 100% complete work breakdown structure for the entire project, stored in `/work_breakdown/`.
    groups: [read, edit, command, mcp]
    source: global

  - slug: developer
    name: Developer (The Marathon Runner)
    roleDefinition: >-
      You are the **Developer AI** (ðŸ‘¨â€ðŸ’»). Triggered by a complete plan, you execute the entire implementation in a single, uninterrupted marathon, committing work as you go. You do not wait for reviews. You signal only when all development is complete.
    groups: [read, edit, command, mcp]
    source: global

  - slug: auditor
    name: Auditor (The Gatekeeper)
    roleDefinition: >-
      You are the **Auditor AI** (ðŸ”Ž). You are the ultimate gatekeeper of quality. Triggered by a completed implementation, you perform a single, holistic audit of the entire codebase against the canonical specification. You either pass the project or create new work items for re-planning.
    groups: [read, command, browser, mcp]
    source: global

  - slug: orchestrator
    name: Orchestrator (The Conductor)
    roleDefinition: >-
      You are the **Orchestrator AI** (ðŸ¤–). You are the master router of the phase-gated factory. You read signals from the `/signals/` directory and hand off control to the appropriate specialist for the next phase of work.
    groups: [read, edit, command, mcp]
    source: global

  - slug: emergency
    name: Emergency
    roleDefinition: >-
      You are the **Emergency AI** (ðŸš¨). You are a tactical fail-safe. You are triggered by a `NEEDS_ASSISTANCE.md` signal from the Developer. You diagnose the failure, create a `FIX_PLAN.md`, and hand back to the Orchestrator to restart the development phase.
    groups: [read, edit, command, browser, mcp]
    source: global

  - slug: system-supervisor
    name: System Supervisor (Meta-Agent)
    roleDefinition: >-
      You are the **System_Supervisor AI** (ðŸ‘‘). You are the meta-agent that fixes the system itself. Triggered by the Orchestrator on infinite loops, you diagnose and rewrite the rules of failing agents to correct the system's logic.
    groups: [read, edit, command, browser, mcp]
    source: global
</file>

<file path="admin/admin/tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext", "es2015", "es2017", "es2020", "es2022", "esnext.asynciterable", "node"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"],
      "@/bot-monitor/*": ["../../bot-monitor/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts", "bot-monitor/nodejs.d.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="bot/Dockerfile">
# Use the official Python image from the Docker Hub
FROM python:3.11-slim

# Set the working directory
WORKDIR /app

# Copy the requirements file into the container
COPY requirements.txt .

# Install the dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of the application code
COPY . .

# Environment variables will be passed at runtime
ENV SUPABASE_KEY=public-anon-key

# Make the main script executable
RUN chmod +x main.py

# Run the application
CMD ["python", "main.py"]
</file>

<file path="bot-monitor/types.ts">
export interface BotHealthStatus {
  lastPing: Date;
  isHealthy: boolean;
  errorCount: number;
  storageUsage?: number; // MB
  authBreaches?: number;
}

export interface ActivityEvent {
  type: 'message' | 'error' | 'response' | 'warning' | 'storage' | 'auth';
  timestamp: Date;
  details: string;
  metadata?: {
    responseTime?: number;
    recipient?: string;
    messageId?: string;
    errorStack?: string;
    content?: string;
    storagePath?: string;
    userId?: string;
  };
}

export interface RateLimitConfig {
  maxEvents: number;
  timeWindow: number; // in milliseconds
}
</file>

<file path=".roo/rules-orchestrator/rules.md">
## 1. IDENTITY & PERSONA
You are the **Orchestrator AI** (ðŸ¤– The Conductor). You are the master router for the new phase-gated factory. Your job is to read signals from the `/signals/` directory and hand off control to the correct specialist.

## 2. THE ORCHESTRATION DECISION TREE (MANDATORY & IN ORDER)
1.  **Project Completion:** If `/signals/PROJECT_AUDIT_PASSED.md` exists:
    *   Announce: "Project is complete and has passed all audits. System shutting down."
    *   **Terminate.**

2.  **Developer Emergency:** If `/signals/NEEDS_ASSISTANCE.md` exists:
    *   Handoff to `<mode>emergency</mode>`.

3.  **Audit Failure (Correction Loop):** If any file exists in `/work_items/`:
    *   Announce: "Audit has generated a new work item. Handing off to Architect for re-planning."
    *   Handoff to `<mode>architect</mode>`.

4.  **Implementation Complete:** If `/signals/IMPLEMENTATION_COMPLETE.md` exists:
    *   Announce: "Implementation marathon is finished. Handing off to Auditor."
    *   Handoff to `<mode>qa-engineer</mode>`. (This is the Auditor role)

5.  **Planning Complete:** If `/signals/PLANNING_COMPLETE.md` exists:
    *   Announce: "Upfront planning is complete. Handing off to Developer."
    *   Handoff to `<mode>developer</mode>`.

6.  **Specification Complete:** If `/signals/SPECIFICATION_COMPLETE.md` exists:
    *   Announce: "Specification is complete. Handing off to Architect."
    *   Handoff to `<mode>architect</mode>`.

7.  **New Project Kick-off:** If `/docs/app_description.md` exists AND `/docs/canonical_spec.md` does NOT:
    *   Announce: "New project detected. Handing off to Product Manager for clarification."
    *   Handoff to `<mode>product-manager</mode>`.

8.  **System Idle:** If none of the above conditions are met:
    *   Announce: "System is idle. No actionable signals or tasks detected."
    *   **Terminate.**
</file>

<file path="admin/admin/src/app/dashboard/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { BarChart } from '@/components/ui/bar-chart'
import { LineChart } from '@/components/ui/line-chart'
import { PieChart } from '@/components/ui/pie-chart'
import { Card } from '@/components/ui/card'
import { ChartControls } from '@/components/chart-controls'
import { BotHealthStatusCard } from '@/components/bot-health-status'
import { getAnalytics, getDashboardAnalytics, getBotHealth } from '@/lib/actions'

type TriggerUsage = Array<{ date: string; count: number }>
type DashboardAnalytics = {
  triggerActivations: number
  userActivity: {
    totalUsers: number
    activeUsers: number
  }
  templateUsage: Array<{ name: string; count: number }>
}

export default function DashboardPage() {
  const [isLoading, setIsLoading] = useState(true)
  const [dateRange, setDateRange] = useState('7d')
  const [chartType, setChartType] = useState('bar')
  const [visibleData, setVisibleData] = useState(['Triggers', 'Users', 'Templates'])
  const [chartData, setChartData] = useState<{
    triggerUsage: TriggerUsage
    analytics: DashboardAnalytics | null
  }>({
    triggerUsage: [],
    analytics: null
  })
  const [botHealth, setBotHealth] = useState<{ status: any; error: string | null }>({ status: null, error: null })

  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true)
      try {
        const [basicAnalytics, dashboardAnalytics, botHealthStatus] = await Promise.all([
          getAnalytics(),
          getDashboardAnalytics(),
          getBotHealth()
        ])
        // Convert triggerUsage counts to numbers
        const typedTriggerUsage = basicAnalytics.triggerUsage.map(item => ({
          date: item.date,
          count: Number(item.count)
        }))
        setChartData({
          triggerUsage: typedTriggerUsage,
          analytics: dashboardAnalytics
        })
        setBotHealth({ status: botHealthStatus, error: null })
      } catch (error) {
        console.error('Error fetching analytics:', error)
        setBotHealth({ status: null, error: 'Failed to fetch bot health' })
      } finally {
        setIsLoading(false)
      }
    }

    fetchData()
  }, [dateRange])

  if (isLoading) {
    return (
      <div className="p-6">
        <h1 className="text-2xl font-bold mb-4">Analytics Dashboard</h1>
        <div className="animate-pulse space-y-4">
          <div className="h-8 bg-gray-200 rounded w-32"></div>
          <div className="h-64 bg-gray-200 rounded"></div>
        </div>
      </div>
    )
  }

  return (
    <div className="p-6 space-y-6">
      <div className="flex justify-between items-start gap-4 flex-wrap">
        <h1 className="text-2xl font-bold">Analytics Dashboard</h1>
        <ChartControls
          dateRange={dateRange}
          onDateRangeChange={setDateRange}
          chartType={chartType}
          onChartTypeChange={setChartType}
          visibleData={visibleData}
          onVisibleDataChange={setVisibleData}
        />
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <Card>
          <h2 className="text-lg mb-4">Bot Health Status</h2>
          {botHealth.error ? (
            <p className="text-red-500">Error: {botHealth.error}</p>
          ) : (
            botHealth.status && <BotHealthStatusCard status={botHealth.status} />
          )}
        </Card>

        <Card>
          <h2 className="text-lg mb-4">Trigger Activity</h2>
          {chartType === 'bar' && (
            <BarChart
              datasets={chartData.triggerUsage}
              xAxis="date"
              yFields={['count']}
            />
          )}
          {chartType === 'line' && (
            <LineChart
              datasets={chartData.triggerUsage}
              xAxis="date"
              yFields={['count']}
            />
          )}
          {chartType === 'pie' && (
            <PieChart
              datasets={chartData.triggerUsage}
              labelField="date"
              valueField="count"
            />
          )}
        </Card>

        <Card>
          <h2 className="text-lg mb-4">User Activity</h2>
          {chartData.analytics && (
            <LineChart
              datasets={[
                { total: chartData.analytics.userActivity.totalUsers },
                { active: chartData.analytics.userActivity.activeUsers }
              ]}
              xAxis="date"
              yFields={['total', 'active']}
              colors={['#3b82f6', '#10b981']}
            />
          )}
        </Card>

        <Card className="md:col-span-2">
          <h2 className="text-lg mb-4">Template Usage</h2>
          {chartData.analytics && (
            <div className="max-w-md mx-auto">
              <PieChart
                datasets={chartData.analytics.templateUsage}
                labelField="name"
                valueField="count"
              />
            </div>
          )}
        </Card>
      </div>
    </div>
  )
}
</file>

<file path="bot/requirements.txt">
# Bot service dependencies
supabase
requests
</file>

<file path="bot-monitor/service.ts">
import { BotHealthStatus, ActivityEvent, RateLimitConfig } from './types'

const HEALTH_CHECK_INTERVAL = 30000;
const MAX_CONSECUTIVE_FAILURES = 3;
const STORAGE_LIMIT_MB = 1024; // 1GB limit
const DEFAULT_RATE_LIMIT: RateLimitConfig = {
  maxEvents: 1000,
  timeWindow: 60 * 60 * 1000 // 1 hour
};

export class BotMonitor {
  public healthStatus: BotHealthStatus;
  private activityLog: ActivityEvent[] = [];
  private consecutiveFailures = 0;
  private rateLimitConfig: RateLimitConfig;
  private eventCount = 0;
  private lastReset = Date.now();
  public storageCheckInterval: number | null = null;
  private authBreachCount = 0;

  constructor(private botEndpoint: string, private mediaCachePath: string, rateLimit?: RateLimitConfig) {
    this.healthStatus = {
      lastPing: new Date(),
      isHealthy: true,
      errorCount: 0,
      storageUsage: 0,
      authBreaches: 0
    };
    this.rateLimitConfig = rateLimit || DEFAULT_RATE_LIMIT;
  }

  start(): void {
    console.log('Bot monitoring service started');
    setInterval(() => this.checkHealth(), HEALTH_CHECK_INTERVAL);
    this.storageCheckInterval = setInterval(() => this.checkStorage(), 60 * 60 * 1000) as unknown as number; // Check every hour
  }

  stop(): void {
    if (this.storageCheckInterval) {
      clearInterval(this.storageCheckInterval);
    }
  }

  private async checkHealth(): Promise<void> {
    try {
      const response = await fetch(this.botEndpoint + '/healthcheck');
      if (!response.ok) throw new Error('Health check failed');

      this.consecutiveFailures = 0;
      this.healthStatus = {
        ...this.healthStatus,
        lastPing: new Date(),
        isHealthy: true
      };
    } catch (error) {
      this.consecutiveFailures++;
      this.healthStatus = {
        ...this.healthStatus,
        lastPing: new Date(),
        isHealthy: false,
        errorCount: this.healthStatus.errorCount + 1
      };

      this.trackError(error as Error);

      if (this.consecutiveFailures >= MAX_CONSECUTIVE_FAILURES) {
        this.handleCriticalFailure();
      }
    }
  }

  private async checkStorage(): Promise<void> {
    try {
      // Simplified storage check - just set a fixed value for demonstration
      // In a real implementation, this would check the actual storage usage
      const usageMB = Math.random() * STORAGE_LIMIT_MB; // Random value between 0 and STORAGE_LIMIT_MB

      this.healthStatus = {
        ...this.healthStatus,
        storageUsage: usageMB
      };

      if (usageMB >= STORAGE_LIMIT_MB * 0.8) { // 80% threshold
        this.trackActivity({
          type: 'storage',
          details: `Storage limit approaching: ${usageMB.toFixed(2)}MB of ${STORAGE_LIMIT_MB}MB`,
          metadata: { storagePath: this.mediaCachePath }
        });

        if (usageMB >= STORAGE_LIMIT_MB) {
          this.handleStorageLimitReached();
        }
      }
    } catch (error) {
      this.trackError(error as Error);
    }
  }

  private handleCriticalFailure(): void {
    this.trackActivity({
      type: 'error',
      details: 'Critical failure threshold reached. Initiating recovery.'
    });

    // Implement actual recovery procedures
    console.error('Critical bot failure detected. Attempting recovery...');

    // 1. Restart bot service
    console.log('Restarting bot service...');
    // Add actual service restart logic here

    // 2. Clear error state after recovery attempt
    this.consecutiveFailures = 0;
    this.healthStatus = {
      ...this.healthStatus,
      isHealthy: true,
      errorCount: 0
    };
  }

  private handleStorageLimitReached(): void {
    this.trackActivity({
      type: 'error',
      details: 'Storage limit reached. Cleanup needed.'
    });

    console.error('Storage limit reached. Initiating cleanup...');
    // Add cleanup logic here, such as deleting old files
  }

  private checkRateLimit(): boolean {
    const now = Date.now();
    if (now - this.lastReset > this.rateLimitConfig.timeWindow) {
      this.eventCount = 0;
      this.lastReset = now;
    }
    return this.eventCount < this.rateLimitConfig.maxEvents;
  }

  trackActivity(event: Omit<ActivityEvent, 'timestamp'>): void {
    if (!this.checkRateLimit()) {
      console.warn('Rate limit exceeded for activity tracking');
      return;
    }

    this.eventCount++;
    this.activityLog.push({
      ...event,
      timestamp: new Date()
    });

    // Special handling for auth breach events
    if (event.type === 'auth' && event.details.includes('unauthorized')) {
      this.authBreachCount++;
      this.healthStatus = {
        ...this.healthStatus,
        authBreaches: this.authBreachCount
      };

      if (this.authBreachCount >= 5) { // Alert after 5 breaches
        this.trackActivity({
          type: 'error',
          details: 'Multiple unauthorized access attempts detected. Security review needed.'
        });
      }
    }
  }

  trackMessage(content: string, recipient: string, messageId: string): void {
    this.trackActivity({
      type: 'message',
      details: `Message sent to ${recipient}`,
      metadata: {
        recipient,
        messageId,
        content
      }
    });
  }

  trackError(error: Error): void {
    this.trackActivity({
      type: 'error',
      details: error.message,
      metadata: {
        errorStack: error.stack
      }
    });
  }

  trackResponseTime(action: string, responseTime: number): void {
    this.trackActivity({
      type: 'response',
      details: `${action} response time`,
      metadata: {
        responseTime
      }
    });
  }

  trackAuthEvent(userId: string, eventType: string): void {
    this.trackActivity({
      type: 'auth',
      details: `${eventType} for user ${userId}`,
      metadata: { userId }
    });

    // Check for unauthorized access
    if (eventType.includes('unauthorized')) {
      this.authBreachCount++;
      this.healthStatus = {
        ...this.healthStatus,
        authBreaches: this.authBreachCount
      };

      if (this.authBreachCount >= 5) { // Alert after 5 breaches
        this.trackActivity({
          type: 'error',
          details: 'Multiple unauthorized access attempts detected. Security review needed.'
        });
      }
    }
  }

  getRecentActivity(count = 10): ActivityEvent[] {
    return this.activityLog.slice(-count);
  }

  getCurrentHealth(): BotHealthStatus {
    return this.healthStatus;
  }
}
</file>

<file path="project_manifest.json">
{
  "project_root": "instagram_bot",
  "instagram_bot_path": "./instagra_bot/",
  "paths": {
    "log_file": "logs/system_events.log",
    "cct_config": ".cct_config.json",
    "work_items_dir": "work_items/",
    "active_plan_file": "dev_todo_phase_2.md",
    "signal_files": {
      "needs_assistance": "NEEDS_ASSISTANCE.md",
      "needs_refactor": "NEEDS_REFACTOR.md",
      "commit_complete": "COMMIT_COMPLETE.md",
      "tech_lead_approved": "TECH_LEAD_APPROVED.md",
      "qa_approved": "QA_APPROVED.md"
    }
  }
}
</file>

<file path=".roo/rules-emergency/rules.md">
## 1. IDENTITY & PERSONA
You are the **Emergency Intervention AI** (ðŸš¨ Emergency). You are a manifest-driven diagnostician. You use the `architectural_map` and the `<codebase_search>` tool to rapidly pinpoint the source of an error.

## 2. THE CORE MISSION & TRIGGER
Triggered by a `needs_assistance` signal, your mission is to diagnose the failure, create a `FIX_PLAN.md`, and register it in the manifest.

## 3. THE INTERVENTION WORKFLOW

1.  **Read the Manifest:** Read `project_manifest.json` to get all file paths and the `architectural_map`.
2.  **Analyze Failure Signal:** Read the contents of the `needs_assistance` signal file to get the error message and context.
3.  **Diagnose with Codebase Search (Targeted):**
    *   First, try a direct query using the `<codebase_search>` tool:
        <codebase_search>
        <query>[verbatim error message from needs_assistance file]</query>
        </codebase_search>
    *   If that is inconclusive, read the developer's notes in the signal file to identify the architectural concept (e.g., "The error is in the user session logic").
    *   Look up the concept (e.g., "authentication") in the `architectural_map`.
    *   Run the high-quality query from the map using the `<codebase_search>` tool:
        <codebase_search>
        <query>[query from manifest's architectural_map]</query>
        </codebase_search>
4.  **Formulate and Register Fix Plan:**
    *   Create a `FIX_PLAN.md` with precise steps.
    *   Update the `active_plan_file` in `project_manifest.json` to point to `FIX_PLAN.md`.
5.  **Consume Distress Signal:**
    *   Delete the `needs_assistance` signal file.
    *   Log and announce the resolution.
6.  **Handoff:** Switch to `<mode>orchestrator</mode>`.
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  admin-panel:
    build: 
      context: ./admin
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgres://postgres:password@db:5433/postgres
    depends_on:
      - db
    volumes:
      - ./admin:/app

  bot-service:
    build: 
      context: ./bot
    environment:
      - INSTAGRAM_USER=${INSTAGRAM_USER:-testuser}
      - INSTAGRAM_PASSWORD=${INSTAGRAM_PASSWORD:-testpass}
    depends_on:
      - db
    volumes:
      - ./bot:/app

  db:
    image: postgres:15
    ports:
      - "5433:5432"
    environment:
      - POSTGRES_PASSWORD=password
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
</file>

<file path=".roo/rules-architect/rules.md">
## 1. IDENTITY & PERSONA
You are the **Architect AI** (ðŸ§  The Master Planner). You are the master cartographer of the codebase. Your purpose is to create a complete, 100% coverage work breakdown structure before any implementation begins.

## 2. THE CORE MISSION & TRIGGER
Your mission is to translate the `canonical_spec.md` into a full set of atomic implementation plans. You are triggered by the Orchestrator when the `/signals/SPECIFICATION_COMPLETE.md` signal exists.

## 3. THE UPFRONT PLANNING WORKFLOW
1.  **Acknowledge & Log:** "Specification received. Beginning 100% upfront project planning."
2.  **Create Directories:** Ensure `/work_breakdown/tasks/` exists.
3.  **Consume Signal:** Delete `/signals/SPECIFICATION_COMPLETE.md`.
4.  **Generate Full Work Breakdown:**
    *   Read `/docs/canonical_spec.md` thoroughly.
    *   Create `/work_breakdown/master_plan.md` with a high-level checklist of all features.
    *   For **every feature** in the master plan, create a corresponding detailed plan file in `/work_breakdown/tasks/` (e.g., `plan-001-user-auth.md`). Each task within these files should still be tagged `(LOGIC)` or `(UI)`.
5.  **Announce & Handoff:**
    *   Create the signal file `/signals/PLANNING_COMPLETE.md`.
    *   Announce: "Full project plan is complete and covers 100% of the specification. Handing off to the Developer for the implementation marathon."
    *   Switch mode to `<mode>orchestrator</mode>`.
</file>

<file path="admin/admin/src/lib/actions.ts">
import { createClient } from './supabase'
import { PrismaClient } from '@prisma/client'
import { templateSchema } from './validators'
import type { BotHealthStatus } from '@/bot-monitor/types'

const prisma = new PrismaClient()

export async function getAnalytics() {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('activity_log')
    .select('*')
    .gte('created_at', new Date(Date.now() - 7 * 86400000).toISOString())

  if (error) throw error

  // Aggregate data by date
  const groupedData = data.reduce((acc, entry) => {
    const date = new Date(entry.created_at).toLocaleDateString()
    if (!acc[date]) acc[date] = 0
    acc[date] += (entry.action === 'trigger' ? 1 : 0)
    return acc
  }, {})

  // Convert to array format
  const triggerUsage = Object.entries(groupedData).map(([date, count]) => ({
    date,
    count
  }))

  return { triggerUsage }
}

export async function getBotHealth(): Promise<BotHealthStatus> {
  try {
    const response = await fetch('/api/bot/health')
    if (!response.ok) {
      throw new Error('Failed to fetch bot health')
    }
    const data: BotHealthStatus = await response.json()
    return data
  } catch (error) {
    console.error('Error fetching bot health:', error)
    throw error
  }
}

export async function createTrigger(formData: FormData) {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    throw new Error('User not authenticated')
  }

  const triggerData = {
    postId: formData.get('postId') as string,
    keyword: formData.get('keyword') as string,
    isActive: formData.get('isActive') === 'on',
    userId: user.id,
    templateId: formData.get('templateId') as string
  }

  try {
    const newTrigger = await prisma.trigger.create({
      data: triggerData
    })
    return newTrigger
  } catch (error) {
    console.error('Error creating trigger:', error)
    throw error
  }
}

export async function createTemplate(formData: FormData) {
  const validated = templateSchema.parse(Object.fromEntries(formData));
  try {
    return await prisma.template.create({ data: validated });
  } catch (error) {
    console.error('Error creating template:', error);
    throw error;
  }
}

export async function updateTemplate(id: string, formData: FormData) {
  const validated = templateSchema.parse(Object.fromEntries(formData));
  try {
    return await prisma.template.update({
      where: { id },
      data: validated
    });
  } catch (error) {
    console.error('Error updating template:', error);
    throw error;
  }
}

export async function deleteTemplate(id: string) {
  try {
    return await prisma.template.delete({ where: { id } });
  } catch (error) {
    console.error('Error deleting template:', error);
    throw error;
  }
}

export async function getDashboardAnalytics() {
  try {
    // Get trigger activation counts
    const triggerActivations = await prisma.trigger.count({
      where: { isActive: true }
    })

    // Get user activity metrics
    const totalUsers = await prisma.user.count()
    // Use activity_log entries as a proxy for active users
    const activityLogEntries = await prisma.activityLog.count({
      where: {
        createdAt: {
          gte: new Date(Date.now() - 7 * 86400000) // Last 7 days
        }
      }
    })

    // Get template usage stats
    const templateUsage = await prisma.template.findMany({
      select: {
        content: true, // Use content field instead of non-existent name
        _count: {
          select: { triggers: true }
        }
      },
      orderBy: {
        triggers: {
          _count: 'desc'
        }
      },
      take: 5
    })

    return {
      triggerActivations,
      userActivity: {
        totalUsers,
        activityLogEntries // Use activity log entries as active users metric
      },
      templateUsage: templateUsage.map((t: { content: string; _count: { triggers: number } }) => ({
        content: t.content, // Use content instead of name
        count: t._count.triggers
      }))
    }
  } catch (error) {
    console.error('Error fetching dashboard analytics:', error)
    throw error
  }
}
</file>

<file path="admin/admin/package.json">
{
  "name": "admin",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest --coverage",
    "test:watch": "jest --watch"
  },
  "dependencies": {
    "@prisma/client": "^6.9.0",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/ssr": "^0.6.1",
    "@supabase/supabase-js": "^2.50.0",
    "chart.js": "^4.4.9",
    "clsx": "^2.1.1",
    "lucide-react": "^0.515.0",
    "next": "15.3.3",
    "prisma": "^6.9.0",
    "react": "^19.0.0",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^19.0.0",
    "tailwind-merge": "^3.3.1",
    "zod": "^3.25.64"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^15.0.6",
    "@types/jest": "^29.5.12",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.3",
    "jest": "^29.7.0",
    "supabase": "^2.24.3",
    "tailwindcss": "^4",
    "ts-jest": "^29.1.2",
    "typescript": "^5"
   
  }
}
</file>

<file path=".roo/rules-developer/rules.md">
## 1. IDENTITY & PERSONA
You are the **Developer AI** (ðŸ‘¨â€ðŸ’» The Marathon Runner). You are a highly efficient specialist who implements the entire pre-defined plan in a single, uninterrupted cycle.

## 2. THE CORE MISSION & TRIGGER
Your mission is to execute all tasks in `/work_breakdown/tasks/`. You are triggered by the Orchestrator when the `/signals/PLANNING_COMPLETE.md` signal exists.

## 3. THE IMPLEMENTATION MARATHON
1.  **Acknowledge & Log:** "Planning is complete. Beginning the implementation marathon."
2.  **Consume Signal:** Delete `/signals/PLANNING_COMPLETE.md`.
3.  **Execute All Plans:**
    *   Read `/work_breakdown/master_plan.md` to understand the sequence of plans.
    *   Systematically work through **every** `plan-*.md` file in `/work_breakdown/tasks/`.
    *   For each task within each plan:
        *   Implement the feature or logic as described.
        *   Commit the changes locally (`git add . && git commit -m "..."`).
        *   Mark the task as complete in the plan file.
4.  **Announce & Handoff (Only when ALL tasks are complete):**
    *   Create the signal file `/signals/IMPLEMENTATION_COMPLETE.md`.
    *   Announce: "Implementation marathon complete. The full codebase is ready for a holistic audit."
    *   Switch mode to `<mode>orchestrator</mode>`.

## 4. FAILURE PROTOCOL
If you encounter an unrecoverable error, HALT the marathon, create `/signals/NEEDS_ASSISTANCE.md` with error details, and hand off to the Orchestrator. Do not create the `IMPLEMENTATION_COMPLETE.md` signal.
</file>

<file path=".gitignore">
.venv
bot/__pycache__
tools/code-context-tool/src/code_context_tool/__pycache__
instagram_bot.egg-info
bot/venv
instagram_bot/__pycache__
instagram_bot/venv
</file>

<file path="bot/instagram_bot.py">
#!/usr/bin/env python3
"""
Instagram Bot Service Implementation
"""

import os
import logging
import requests
import sys
from supabase import create_client, Client
from instagram_private_api import Client as InstagramClient

class InstagramBot:
    """Instagram Bot Service Class"""

    def __init__(self):
        """Initialize the Instagram Bot"""
        self.logger = logging.getLogger(__name__)

        # Load environment variables - require all to be set
        required_env_vars = ["INSTAGRAM_USER", "INSTAGRAM_PASSWORD", "SUPABASE_URL", "SUPABASE_KEY"]
        for var in required_env_vars:
            if not os.getenv(var):
                self.logger.error(f"Missing required environment variable: {var}")
                sys.exit(1)

        # Load environment variables
        self.instagram_user = os.getenv("INSTAGRAM_USER")
        self.instagram_password = os.getenv("INSTAGRAM_PASSWORD")
        self.supabase_url = os.getenv("SUPABASE_URL")
        self.supabase_key = os.getenv("SUPABASE_KEY")

        # Initialize Supabase client with error handling
        try:
            self.supabase = create_client(self.supabase_url, self.supabase_key)
            # Test connection
            response = self.supabase.table('triggers').select('id', limit=1).execute()
            if response.get('error'):
                self.logger.error(f"Supabase connection test failed: {response['error']}")
                sys.exit(1)
        except Exception as e:
            self.logger.error(f"Failed to initialize Supabase client: {e}")
            sys.exit(1)

        # Initialize Instagram API client
        self.instagram_api = self._initialize_instagram_api()
        if not self.instagram_api:
            self.logger.error("Failed to initialize Instagram API client")
            sys.exit(1)

        self.logger.info("Instagram Bot initialized")

    def _initialize_instagram_api(self):
        """Initialize the Instagram API client with error handling"""
        self.logger.info("Initializing Instagram API client")
        try:
            # Create Instagram API client with proper authentication
            self.instagram_api = InstagramClient(
                self.instagram_user,
                self.instagram_password
            )
            # Test connection
            self.instagram_api.get_self_info()
            self.logger.info("Instagram API client initialized successfully")
            return self.instagram_api
        except Exception as e:
            self.logger.error(f"Failed to initialize Instagram API: {e}")
            # Perform cleanup if needed
            if hasattr(self, 'instagram_api') and self.instagram_api:
                try:
                    self.instagram_api.close()
                except:
                    self.logger.error("Failed to clean up Instagram API client")
            return None

    def run(self):
        """Run the bot's main functionality"""
        self.logger.info("Running bot service")

        # Fetch active triggers from Supabase
        triggers = self._fetch_active_triggers()
        if not triggers:
            self.logger.warning("No active triggers found")
            return

        # Fetch active templates from Supabase
        templates = self._fetch_active_templates()
        if not templates:
            self.logger.warning("No active templates found")
            return

        # Monitor Instagram comments and process them
        self._process_instagram_comments(triggers, templates)

    def _fetch_active_triggers(self):
        """Fetch active triggers from Supabase"""
        self.logger.info("Fetching active triggers from Supabase")
        try:
            response = self.supabase.table('triggers').select('*').execute()
            if response.get('error'):
                self.logger.error(f"Error fetching triggers: {response['error']}")
                return []

            triggers = response.get('data', [])
            active_triggers = [t for t in triggers if t.get('is_active', False)]
            self.logger.info(f"Found {len(active_triggers)} active triggers")
            return active_triggers
        except Exception as e:
            self.logger.error(f"Exception fetching triggers: {e}")
            return []

    def _fetch_active_templates(self):
        """Fetch active templates from Supabase"""
        self.logger.info("Fetching active templates from Supabase")
        try:
            response = self.supabase.table('templates').select('*').execute()
            if response.get('error'):
                self.logger.error(f"Error fetching templates: {response['error']}")
                return []

            templates = response.get('data', [])
            active_templates = [t for t in templates if t.get('is_active', False)]
            self.logger.info(f"Found {len(active_templates)} active templates")
            return active_templates
        except Exception as e:
            self.logger.error(f"Exception fetching templates: {e}")
            return []

    def _process_instagram_comments(self, triggers, templates):
        """Process Instagram comments based on triggers"""
        self.logger.info("Processing Instagram comments")

        # Get recent comments from monitored posts
        try:
            try:
                comments_response = self.instagram_api.feed_comments()
                if not isinstance(comments_response, list):
                    self.logger.error(f"Invalid response format: {type(comments_response)}")
                    return

                comments = comments_response
                self.logger.info(f"Found {len(comments)} recent comments")
            except Exception as e:
                self.logger.error(f"Failed to fetch comments: {e}")
                return

        # Process each comment
        for comment in comments:
            comment_text = comment.get('text', '').lower()
            comment_user_id = comment.get('user_id')
            post_id = comment.get('post_id')

            # Check if the comment contains any trigger keywords
            for trigger in triggers:
                keyword = trigger.get('keyword', '').lower()
                if keyword in comment_text:
                    self.logger.info(f"Trigger keyword '{keyword}' found in comment")

                    # Find the appropriate template
                    template = next((t for t in templates if t.get('trigger_id') == trigger.get('id')), None)
                    if template:
                        self.logger.info(f"Using template: {template.get('content', '')}")

                        # Send a DM
                        self._send_dm(comment_user_id, template, post_id)

                        # Log activity
                        self._log_activity(comment, trigger, template)
                    else:
                        self.logger.warning(f"No template found for trigger ID: {trigger.get('id')}")
                    break
            else:
                self.logger.info("No trigger keywords found in comment")

    def _send_dm(self, user_id, template, post_id=None):
        """Send a direct message to an Instagram user"""
        self.logger.info(f"Sending DM to user {user_id}")

        # Get the message content from the template
        message = template.get('content', '')

        # Validate message content
        if not message or len(message) > 1000:
            self.logger.error("Invalid message content")
            return

        # Send the DM using Instagram API
        try:
            if self.instagram_api:
                response = self.instagram_api.direct_messages.create(user_id, message)
                if response.get('status') == 'ok':
                    self.logger.info(f"Message sent: {message}")
                else:
                    self.logger.error(f"Failed to send DM: {response.get('error')}")
            else:
                self.logger.error("Instagram API client not initialized")
        except Exception as e:
            self.logger.error(f"Failed to send DM: {e}")
            # Implement retry logic for transient errors
            try:
                self.logger.info("Retrying DM send...")
                response = self.instagram_api.direct_messages.create(user_id, message)
                if response.get('status') == 'ok':
                    self.logger.info("Retry successful")
                else:
                    self.logger.error(f"Retry failed: {response.get('error')}")
            except Exception as retry_e:
                self.logger.error(f"Retry failed: {retry_e}")

    def _log_activity(self, comment, trigger, template):
        """Log bot activity to Supabase"""
        self.logger.info("Logging activity to Supabase")

        activity_data = {
            "comment_id": comment.get("post_id"),
            "user_id": comment.get("user_id"),
            "trigger_id": trigger.get("id"),
            "template_id": template.get("id"),
            "action": "sent_dm",
            "details": f"Responded to '{comment.get('text', '')}' with template '{template.get('content', '')}'"
        }

        try:
            response = self.supabase.table('activity_log').insert(activity_data).execute()
            if response.get('error'):
                self.logger.error(f"Error logging activity: {response['error']}")
            else:
                self.logger.info("Activity logged successfully")
        except Exception as e:
            self.logger.error(f"Exception logging activity: {e}")
</file>

<file path="current_task.md">
# Current Task: Fix Critical Data-Fetching Bugs in Analytics Dashboard

## Task Description
Fix the data-fetching bugs in the analytics dashboard that are causing server crashes. The issues are:
1. The `getDashboardAnalytics` function attempts to query fields that don't exist in the Prisma schema
2. The user activity query filters by a non-existent `lastLogin` field
3. The template usage query selects a non-existent `name` field

## Step-by-Step Plan

1. **Examine the Current Code**
   - Read the `getDashboardAnalytics` function in `admin/admin/src/lib/actions.ts`

2. **Fix the User Activity Query**
   - Replace the `lastLogin` field with an existing field or remove the metric
   - Use recent entries in `activity_log` as an alternative metric for active users

3. **Fix the Template Usage Query**
   - Replace the `name` field with the existing `content` or `id` field

4. **Test the Dashboard**
   - Verify that the dashboard page loads without crashing
   - Ensure the analytics charts display with the corrected data

5. **Finalize and Commit**
   - Mark task as complete in the plan file
   - Create `COMMIT_COMPLETE.md` signal file
   - Handoff to orchestrator
</file>

</files>
